import { WebPubSubExtensionOptions, debugModule } from "../../common/utils";
import { ClientConnectionContext } from "./client-connection-context";
import { EIO_SERVER_ACCEPT_CONNECTION, EIO_SERVER_REFUSE_CONNECTION } from "./constants";
import { WebPubSubServiceClient } from "@azure/web-pubsub";
import type { BaseServer } from "engine.io";
import {
  ConnectRequest as WebPubSubConnectRequest,
  ConnectResponse as WebPubSubConnectResponse,
  WebPubSubEventHandler,
} from "@azure/web-pubsub-express";
import { Server as HttpServer, IncomingMessage, ServerResponse } from "http";
import express from "express";

const debug = debugModule("wps-sio-ext:EIO:WebPubSubTranslator");

/**
 * A `WebPubSubTranslator` instance is created for each Engine.IO server instance. It's designed to:
 * 1. Manages all Azure Web PubSub client connections and keep them consistent with corresponding EIO clients.
 * 2. Handle upstream invoke requests from AWPS and then translate them into Engine.IO behaviours.
 * 3. Translates Engine.IO behaviours to AWPS behaviours like REST API calls.
 * 4. Makes the EIO `sid` same as its corresponding Azure Web PubSub client connection id.
 */
export class WebPubSubTranslator {
  /**
   * Each `WebPubSubTranslator` instance is bound to a Engine.IO server instance and vice versa.
   */
  public linkedEioServer: BaseServer;

  /**
   * Client for connecting to a Web PubSub hub
   */
  private serviceClient: WebPubSubServiceClient;

  /**
   * Map from the `connectionId` of each client to its corresponding logical `ClientConnectionContext`.
   */
  private clientConnections: Map<string, ClientConnectionContext> = new Map();

  /**
   * Handle upstream invoke requests from AWPS.
   */
  private webPubSubEventHandler: WebPubSubEventHandler;

  /**
   * Options for Azure Web PubSub service.
   */
  private webPubSubOptions: WebPubSubExtensionOptions;

  /**
   * In native Engine.IO, the `sid` of each EIO connnection is generated by server randomly.
   * As for AWPS, it generates `ConnectionId` for each client.
   * For each EIO connection, the extension enforces its `sid` in server side is same as the ConnectionId assigned by service.
   * This array stores all `ConnectionId` which is generated by AWPS and is prepared to be assigned to EIO connection.
   */
  private candidateSids: Array<string> = new Array();

  constructor(server: BaseServer, options: WebPubSubExtensionOptions) {
    debug("constructor");

    this.linkedEioServer = server;
    this.webPubSubOptions = options;
    this.serviceClient = new WebPubSubServiceClient(
      this.webPubSubOptions.connectionString,
      this.webPubSubOptions.hub,
      {
        allowInsecureConnection: true,
      }
    );

    this.webPubSubEventHandler = new WebPubSubEventHandler(this.webPubSubOptions.hub, {
      path: this.webPubSubOptions.path,
      handleConnect: async (req, res) => {
        var connectionId = req.context.connectionId;
        debug(`onConnect, connectionId = ${connectionId}`);

        var context = new ClientConnectionContext(this.serviceClient, connectionId);

        context.on(EIO_SERVER_ACCEPT_CONNECTION, (openPacketPayload: string) => {
          let payloadWithoutType = openPacketPayload.substring(1);
          res.success({
            socketioHandshake: JSON.parse(payloadWithoutType),
          } as WebPubSubConnectResponse);
        });

        context.on(EIO_SERVER_REFUSE_CONNECTION, (errorMessage: string) => {
          res.fail(400, `EIO server refused connection with error: ${errorMessage}`);
        });

        var connectReq = this.convertWebPubsubConnectReqToEioHandshakeReq(req, context);

        this.candidateSids.push(connectionId);
        this.clientConnections.set(connectionId, context);
        // @ts-ignore to access private `handshake` method
        await this.linkedEioServer.handshake("webpubsub", connectReq);
      },

      onConnected: async (req) => {},

      handleUserEvent: async (req, res) => {
        var connectionId = req.context.connectionId;

        debug(`onUserEvent, connectionId = ${connectionId}, req.data = ${req.data}`);

        if (this.clientConnections.has(connectionId)) {
          const handlePayload = (payload: string) => {
            debug(`onUserEvent, connectionId = ${connectionId}, handle payload = ${payload}`);

            // @ts-ignore to access private `clients` property
            var packet = this.linkedEioServer.clients[connectionId].transport.parser.decodePacket(payload); // prettier-ignore

            // @ts-ignore to access private `clients` property
            this.linkedEioServer.clients[connectionId].onPacket(packet);
          };

          debug(`onUserEvent, connectionId = ${connectionId}, req.data = ${req.data}`);

          var payloads = (req.data as string).split(String.fromCharCode(30));
          for (var i = 0; i < payloads.length; i++) {
            handlePayload(payloads[i]);
          }
          return res.success();
        } else {
          return res.fail(401);
        }
      },

      onDisconnected: async (req) => {
        var connectionId = req.context.connectionId;
        debug(`onDisconnected, connectionId = ${connectionId}`);
        if (!this.clientConnections.delete(connectionId)) {
          debug(`onDisconnected, Failed to delete non-existing connectionId = ${connectionId}`);
        }
      },
    });
  }

  /**
   * @returns AWPS event handler middleware for EIO Server.
   */
  public getEventHandlerEioMiddleware() {
    /**
     * AWPS package provides Express middleware for event handlers.
     * However Express middleware is not compatiable to be directly used by EIO Server.
     * So a temporary Express App and HttpServer are created as bridges to convert Express middleware to EIO middleware.
     */
    const expressMiddleware = this.webPubSubEventHandler.getMiddleware();
    
    // Pass Web PubSub Express middlewares into Engine.IO middlewares
    let bridgeApp = express();
    bridgeApp.use(expressMiddleware);
    const bridgeHttpServer = new HttpServer(bridgeApp);

    return bridgeHttpServer.listeners("request")[0];
  } 

  public getNextId = () => this.candidateSids.shift();

  /**
   * Translate a AWPS `connect` request to a Engine.IO `handshake` request.
   * @param req AWPS `connect` request.
   * @param context Corrsponding `ClientConnectionContext` for the incoming client. It will be used in `createTransport` to enable each transport send message to the AWPS client.
   */
  private convertWebPubsubConnectReqToEioHandshakeReq(
    req: WebPubSubConnectRequest,
    context: ClientConnectionContext
  ) {
    var dummyReq: any = {
      method: "GET", // TODO: SDK should expose method in req
      url: this.webPubSubOptions.path,
      headers: {},
      _query: { EIO: req.queries.EIO[0], transport: "websocket" },
      websocket: null,
      statusCode: null,
      statusMessage: null,
      connection: {},
      webPubSubContext: context,
    };
    for (var key in req.headers) {
      let _key = key.toLowerCase();
      dummyReq["headers"][_key] = _key == "upgrade" ? req.headers[key][0] : req.headers[key];
    }
    return dummyReq;
  }
}
