// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import { WebPubSubExtensionOptions, debugModule } from "../../common/utils";
import { ClientConnectionContext } from "./client-connection-context";
import { WEBPUBSUB_CLIENT_CONNECTION_FILED_NAME, WEBPUBSUB_TRANSPORT_NAME } from "./constants";
import { WebPubSubServiceClient } from "@azure/web-pubsub";
import type { BaseServer } from "engine.io";
import {
  ConnectRequest as WebPubSubConnectRequest,
  ConnectResponse as WebPubSubConnectResponse,
  WebPubSubEventHandler,
} from "@azure/web-pubsub-express";

const debug = debugModule("wps-sio-ext:EIO:ConnectionManager");

/**
 * A `WebPubSubConnectionManager` instance is created for each Engine.IO server instance. It's designed to:
 * 1. Manages all Azure Web PubSub client connections and keep them consistent with corresponding EIO clients.
 * 2. Handle upstream invoke requests from AWPS and then translate them into Engine.IO behaviours.
 * 3. Translates Engine.IO behaviours to AWPS behaviours like REST API calls.
 * 4. Makes the EIO `sid` same as its corresponding Azure Web PubSub client connection id.
 */
export class WebPubSubConnectionManager {
  /**
   * Each `WebPubSubConnectionManager` instance is bound to a Engine.IO server instance and vice versa.
   */
  public eioServer: BaseServer;

  /**
   * Client for connecting to a Web PubSub hub
   */
  public serviceClient: WebPubSubServiceClient;

  /**
   * Map from the `connectionId` of each client to its corresponding logical `ClientConnectionContext`.
   */
  private _clientConnections: Map<string, ClientConnectionContext> = new Map();

  /**
   * Handle upstream invoke requests from AWPS.
   */
  private _webPubSubEventHandler: WebPubSubEventHandler;

  /**
   * Options for Azure Web PubSub service.
   */
  private _webPubSubOptions: WebPubSubExtensionOptions;

  /**
   * In native Engine.IO, the `sid` of each EIO connnection is generated by server randomly.
   * As for AWPS, it generates `ConnectionId` for each client.
   * For each EIO connection, the extension enforces its `sid` in server side is same as the ConnectionId assigned by service.
   * This array stores all `ConnectionId` which is generated by AWPS and is prepared to be assigned to EIO connection.
   */
  private _candidateSids: Array<string> = new Array();

  constructor(server: BaseServer, options: WebPubSubExtensionOptions) {
    if (!options.connectionString || options.connectionString === "") {
      throw new Error("Valid connectionString is required");
    }

    if (!options.hub || options.hub === "") {
      throw new Error("Valid hub is required");
    }

    this.eioServer = server;
    this._webPubSubOptions = options;
    this.serviceClient = new WebPubSubServiceClient(
      this._webPubSubOptions.connectionString,
      this._webPubSubOptions.hub,
      this._webPubSubOptions.webPubSubServiceClientOptions
    );

    this._webPubSubEventHandler = new WebPubSubEventHandler(this._webPubSubOptions.hub, {
      path: this._webPubSubOptions.path,
      handleConnect: async (req, res) => {
        let timeout: NodeJS.Timeout;
        try {
          const connectionId = req.context.connectionId;
          debug(`onConnect, connectionId = ${connectionId}`);

          const context = new ClientConnectionContext(this.serviceClient, connectionId, res);

          /**
           * Two conditions lead to returning reponse for connect event:
           *   1. The connection is accepted or refused by EIO Server and the corresponding events are triggered.
           *   2. Exception is thrown in following code
           * As a defensive measure, a timeout is set to return response in 30000ms in case of both conditions don't happen.
           */
          timeout = setTimeout(() => {
            if (!context.connectResponded) {
              res.fail(500, `EIO server cannot handle connect request with error: Timeout 30000ms`);
            }
          }, 30000);

          const connectReq = this.getEioHandshakeRequest(req, context);

          this._candidateSids.push(connectionId);
          this._clientConnections.set(connectionId, context);

          await (this.eioServer as any).handshake(WEBPUBSUB_TRANSPORT_NAME, connectReq);
        } catch (error) {
          debug(`onConnect, req = ${req}, err = ${error}`);
          res.fail(500, `EIO server cannot handle connect request with error: ${error}`);
          clearTimeout(timeout);
        }
      },

      handleUserEvent: async (req, res) => {
        try {
          const connectionId = req.context.connectionId;

          debug(`onUserEvent, connectionId = ${connectionId}, req.data = ${req.data}`);

          if (this._clientConnections.has(connectionId)) {
            const client = (this.eioServer as any).clients[connectionId];

            const packets = await client.transport.parser.decodePayload(req.data); // prettier-ignore

            for (const packet of packets) {
              client.onPacket(packet);
            }
            return res.success();
          } else {
            // `UserEventResponseHandler.fail(code, ...)` cannot set `code` with 404. Only 400, 401 and 500 are available.
            return res.fail(400, `EIO server cannot find ConnectionId ${connectionId}`);
          }
        } catch (err) {
          debug(`onUserEvent, req = ${req}, err = ${err}`);
          return res.fail(500, `EIO server cannot handle user event with error: ${err}`);
        }
      },

      onDisconnected: async (req) => {
        const connectionId = req.context.connectionId;
        debug(`onDisconnected, connectionId = ${connectionId}`);
        if (!this._clientConnections.delete(connectionId)) {
          (this.eioServer as any).clients[connectionId].close(true);
          debug(`onDisconnected, Failed to delete non-existing connectionId = ${connectionId}`);
        }
      },
    });
  }

  /**
   * @returns AWPS event handler middleware for EIO Server.
   */
  public getEventHandlerEioMiddleware(): any {
    /**
     * AWPS package provides Express middleware for event handlers.
     * However Express middleware is not compatiable to be directly used by EIO Server.
     * expressMiddleware = (req: express.Request, res: express.Response, express.NextFunction) =\> void;
     * eioMiddleware = (req: IncomingMessage, res: ServerResponse) =\> void;
     * To resolve the difference, So a conversion from express middleware to EIO middleware.
     */

    const expressMiddleware: any = this._webPubSubEventHandler.getMiddleware();

    const eioMiddleware = (req, res, errorCallback): void => {
      /**
       * `baseUrl` is a property of Express Request object and its used in `expressMiddleware`.
       * Without actual usage as a part of Express, `req.baseUrl` is always ''.
       * Ref https://expressjs.com/en/api.html#req.baseUrl
       */
      req.baseUrl = "";
      req.path = req.url; // e.g. /eventhandler/
      expressMiddleware(req, res, errorCallback);
    };

    return eioMiddleware;
  }

  public getNextSid = (): string => this._candidateSids.shift();

  /**
   * Convert an AWPS `connect` request to an Engine.IO `handshake` request.
   * @param req - AWPS `connect` request.
   * @param context - Corrsponding `ClientConnectionContext` for the connecting client. It will be used in `createTransport` to bind each transport to the correct AWPS client connection.
   */
  private getEioHandshakeRequest(
    req: WebPubSubConnectRequest,
    context: ClientConnectionContext
  ): any {
    /**
     * Properties inside `handshakeRequest` are used in Engine.IO `handshake` method in `Server` class.
     * src: https://github.com/socketio/engine.io/blob/6.0.x/lib/server.ts#L396
     */
    const handshakeRequest: any = {
      method: "GET",
      headers: req.headers,
      connection: {},
      url: this._webPubSubOptions.path,
      _query: {},
    };
    // Preserve all queires. Each value of `req.queries` is an one-element array which is wrapped by AWPS. Just pick out the first element.
    // Example: req.queries = { EIO:['4'], t: ['OXhVRj0'], transport: ['polling'] }.
    for (const key in req.queries) {
      handshakeRequest._query[key] = req.queries[key][0];
    }
    // AWPS helps server abstract the details of Long-Polling and WebSockets with the client. So server always use our own transport `WEBPUBSUB_TRANSPORT_NAME`.
    handshakeRequest._query["transport"] = WEBPUBSUB_TRANSPORT_NAME;
    // AWPS client connection context is passed to Engine.IO `createTransport` method to bind each transport to the correct AWPS client connection.
    handshakeRequest[WEBPUBSUB_CLIENT_CONNECTION_FILED_NAME] = context;
    return handshakeRequest;
  }
}
