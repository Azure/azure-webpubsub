/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@azure/ms-rest-azure-js'), require('@azure/ms-rest-js'), require('jsonwebtoken'), require('url'), require('cloudevents'), require('express')) :
    typeof define === 'function' && define.amd ? define(['exports', '@azure/ms-rest-azure-js', '@azure/ms-rest-js', 'jsonwebtoken', 'url', 'cloudevents', 'express'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.WebPubSub = {}), global.msRestAzure, global.msRest, global.jwt, global.url, global.cloudevents, global.express));
}(this, (function (exports, msRestAzure, msRest, jwt, url, cloudevents, express) { 'use strict';

    jwt = jwt && Object.prototype.hasOwnProperty.call(jwt, 'default') ? jwt['default'] : jwt;
    express = express && Object.prototype.hasOwnProperty.call(express, 'default') ? express['default'] : express;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */
    const CloudError = msRestAzure.CloudErrorMapper;

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const acceptLanguage = {
        parameterPath: "acceptLanguage",
        mapper: {
            serializedName: "accept-language",
            defaultValue: 'en-US',
            type: {
                name: "String"
            }
        }
    };
    const apiVersion = {
        parameterPath: [
            "options",
            "apiVersion"
        ],
        mapper: {
            serializedName: "api-version",
            defaultValue: '2020-10-01',
            type: {
                name: "String"
            }
        }
    };
    const connectionId = {
        parameterPath: "connectionId",
        mapper: {
            required: true,
            serializedName: "connectionId",
            type: {
                name: "String"
            }
        }
    };
    const excluded = {
        parameterPath: [
            "options",
            "excluded"
        ],
        mapper: {
            serializedName: "excluded",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "String"
                    }
                }
            }
        },
        collectionFormat: msRest.QueryCollectionFormat.Multi
    };
    const group0 = {
        parameterPath: "group",
        mapper: {
            required: true,
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const group1 = {
        parameterPath: [
            "options",
            "group"
        ],
        mapper: {
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const hub = {
        parameterPath: "hub",
        mapper: {
            required: true,
            serializedName: "hub",
            type: {
                name: "String"
            }
        }
    };
    const id = {
        parameterPath: "id",
        mapper: {
            required: true,
            serializedName: "id",
            type: {
                name: "String"
            }
        }
    };
    const permission = {
        parameterPath: "permission",
        mapper: {
            required: true,
            serializedName: "permission",
            type: {
                name: "String"
            }
        }
    };
    const reason = {
        parameterPath: [
            "options",
            "reason"
        ],
        mapper: {
            serializedName: "reason",
            type: {
                name: "String"
            }
        }
    };
    const user = {
        parameterPath: "user",
        mapper: {
            required: true,
            serializedName: "user",
            type: {
                name: "String"
            }
        }
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a HealthApi. */
    class HealthApi {
        /**
         * Create a HealthApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        getHealthStatus(options, callback) {
            return this.client.sendOperationRequest({
                options
            }, getHealthStatusOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer = new msRest.Serializer(Mappers);
    const getHealthStatusOperationSpec = {
        httpMethod: "HEAD",
        path: "api/health",
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a WebPubSubApi. */
    class WebPubSubApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, sendToAllOperationSpec, callback);
        }
        checkConnectionExistence(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, checkConnectionExistenceOperationSpec, callback);
        }
        closeClientConnection(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, closeClientConnectionOperationSpec, callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, sendToConnectionOperationSpec, callback);
        }
        checkGroupExistence(hub, group, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                options
            }, checkGroupExistenceOperationSpec, callback);
        }
        sendToGroup(hub, group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                payloadMessage,
                options
            }, sendToGroupOperationSpec, callback);
        }
        addConnectionToGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, addConnectionToGroupOperationSpec, callback);
        }
        removeConnectionFromGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, removeConnectionFromGroupOperationSpec, callback);
        }
        checkUserExistence(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, checkUserExistenceOperationSpec, callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, sendToUserOperationSpec, callback);
        }
        checkUserExistenceInGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, checkUserExistenceInGroupOperationSpec, callback);
        }
        addUserToGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, addUserToGroupOperationSpec, callback);
        }
        removeUserFromGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, removeUserFromGroupOperationSpec, callback);
        }
        removeUserFromAllGroups(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, removeUserFromAllGroupsOperationSpec, callback);
        }
        grantGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, grantGroupPermissionOperationSpec, callback);
        }
        revokeGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, revokeGroupPermissionOperationSpec, callback);
        }
        checkGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, checkGroupPermissionOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer$1 = new msRest.Serializer(Mappers$1);
    const sendToAllOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkConnectionExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const closeClientConnectionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            reason,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToConnectionOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/groups/{group}",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToGroupOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addConnectionToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeConnectionFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToUserOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/users/{id}/:send",
        urlParameters: [
            hub,
            id
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceInGroupOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addUserToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromAllGroupsOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const grantGroupPermissionOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const revokeGroupPermissionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupPermissionOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const packageName = "@azure/webpubsub";
    const packageVersion = "1.0.0";
    class WebPubSubServiceClientContext extends msRestAzure.AzureServiceClient {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            if (credentials == undefined) {
                throw new Error('\'credentials\' cannot be null.');
            }
            if (!options) {
                options = {};
            }
            if (!options.userAgent) {
                const defaultUserAgent = msRestAzure.getDefaultUserAgentValue();
                options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
            }
            super(credentials, options);
            this.acceptLanguage = 'en-US';
            this.longRunningOperationRetryTimeout = 30;
            this.baseUri = options.baseUri || this.baseUri || "http://localhost";
            this.requestContentType = "application/json; charset=utf-8";
            this.credentials = credentials;
            if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
                this.acceptLanguage = options.acceptLanguage;
            }
            if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
                this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
            }
        }
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    class WebPubSubServiceClient extends WebPubSubServiceClientContext {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            super(credentials, options);
            this.healthApi = new HealthApi(this);
            this.webPubSubApi = new WebPubSubApi(this);
        }
    }

    /*
     AutoRest has issue generating code from :
     "consumes": [
              "application/octet-stream",
              "text/plain"
            ],
            "parameters": [
              {
                "in": "body",
                "name": "payloadMessage",
                "required": true,
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }

    */
    /** Class representing a WebPubSubApi. */
    class WebPubSubSendApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, broadcastOperationSpec), callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToUserOperationSpec$1), callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToConnectionOperationSpec$1), callback);
        }
        sendToGroup(group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                group,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, groupBroadcastOperationSpec), callback);
        }
    }
    // Operation Specifications
    const serializer$2 = new msRest.Serializer(Mappers$1);
    const broadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToUserOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/users/{id}/:send",
        urlParameters: [
            hub,
            id
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToConnectionOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const groupBroadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    function fulfillSpec(payloadMessage, baseSepc) {
        if (typeof payloadMessage === "string") {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "String"
                        }
                    }
                }, contentType: "text/plain" });
        }
        else {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "Stream"
                        }
                    }
                }, contentType: "application/octet-stream" });
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubKeyCredentials {
        /**
         * Creates a new TokenCredentials object.
         *
         * @constructor
         * @param {string} key The key.
         */
        constructor(key) {
            if (!key) {
                throw new Error("token cannot be null or undefined.");
            }
            this.key = key;
        }
        /**
         * Signs a request with the Authentication header.
         *
         * @param {WebResourceLike} webResource The WebResourceLike to be signed.
         * @return {Promise<WebResourceLike>} The signed request object.
         */
        signRequest(webResource) {
            var _a;
            if (!webResource.headers)
                webResource.headers = new msRest.HttpHeaders();
            var url = new URL((_a = webResource.url + webResource.query) !== null && _a !== void 0 ? _a : '');
            url.port = '';
            const audience = url.toString();
            webResource.headers.set("Authorization", "Bearer " +
                jwt.sign({}, this.key, {
                    audience: audience,
                    expiresIn: "1h",
                    algorithm: "HS256"
                }));
            return Promise.resolve(webResource);
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubServiceEndpoint {
        /**
         * Creates a new WebPubSubServiceEndpoint object.
         *
         * @constructor
         * @param {string} conn The Connection String.
         */
        constructor(conn) {
            this.conn = conn;
            this.endpoint = this.getServiceEndpoint(conn);
        }
        clientNegotiate(hub, options) {
            var _a;
            var clientUrl = `${this.endpoint.wshost}client/hubs/${hub}`;
            var url$1 = new url.URL(clientUrl);
            url$1.port = '';
            const audience = url$1.toString();
            var key = this.endpoint.key;
            var payload = (_a = options === null || options === void 0 ? void 0 : options.claims) !== null && _a !== void 0 ? _a : {};
            if (options === null || options === void 0 ? void 0 : options.roles) {
                payload.role = options.roles;
            }
            var signOptions = {
                audience: audience,
                expiresIn: "1h",
                algorithm: "HS256",
            };
            if (options === null || options === void 0 ? void 0 : options.userId) {
                signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
            }
            return {
                url: clientUrl,
                token: jwt.sign(payload, key, signOptions),
            };
        }
        getServiceEndpoint(conn) {
            var endpoint = this.parseConnectionString(conn);
            if (!endpoint) {
                throw new Error("Invalid connection string: " + conn);
            }
            return endpoint;
        }
        parseConnectionString(conn) {
            const em = /Endpoint=(.*?)(;|$)/g.exec(conn);
            if (!em)
                return null;
            const endpoint = em[1];
            const km = /AccessKey=(.*?)(;|$)/g.exec(conn);
            if (!km)
                return null;
            const key = km[1];
            if (!endpoint || !key)
                return null;
            const pm = /Port=(.*?)(;|$)/g.exec(conn);
            const port = pm == null ? '' : pm[1];
            var url$1 = new url.URL(endpoint);
            url$1.port = port;
            const host = url$1.toString();
            url$1.port = '';
            const audience = url$1.toString();
            return {
                host: host,
                audience: audience,
                key: key,
                wshost: host.replace('https://', 'wss://').replace('http://', 'ws://')
            };
        }
    }

    // Copyright (c) Microsoft Corporation.
    class ConsoleHttpPipelineLogger {
        /**
         * Create a new ConsoleHttpPipelineLogger.
         * @param minimumLogLevel The log level threshold for what logs will be logged.
         */
        constructor(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
        }
        /**
         * Log the provided message.
         * @param logLevel The HttpLogDetailLevel associated with this message.
         * @param message The message to log.
         */
        log(logLevel, message) {
            const logMessage = `${msRest.HttpPipelineLogLevel[logLevel]}: ${message}`;
            switch (logLevel) {
                case msRest.HttpPipelineLogLevel.ERROR:
                    console.error(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.WARNING:
                    console.warn(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.INFO:
                    console.log(logMessage);
                    break;
            }
        }
    }
    /**
     * Client for connecting to a SignalR hub
     */
    class WebPubSubServiceRestClient {
        constructor(connectionString, hub, options) {
            /**
             * The SignalR API version being used by this client
             */
            this.apiVersion = "2020-10-01";
            this.hub = hub;
            var endpoint = new WebPubSubServiceEndpoint(connectionString);
            this.credential = new WebPubSubKeyCredentials(endpoint.endpoint.key);
            this.client = new WebPubSubServiceClient(this.credential, {
                //httpPipelineLogger: options?.dumpRequest ? new ConsoleHttpPipelineLogger(HttpPipelineLogLevel.INFO) : undefined,
                baseUri: endpoint.endpoint.host,
                requestPolicyFactories: (options === null || options === void 0 ? void 0 : options.dumpRequest) ? this.getFactoryWithLogPolicy : undefined,
            });
            this.sender = new WebPubSubSendApi(this.client);
        }
        getFactoryWithLogPolicy(defaultRequestPolicyFactories) {
            defaultRequestPolicyFactories.push(msRest.logPolicy());
        }
        /**
         * Check if the service is healthy
         *
         * @param options Additional options
         */
        serviceIsHealthy(options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.client.healthApi.getHealthStatus({
                        apiVersion: options.apiVersion
                    });
                    return true;
                }
                catch (_a) {
                    return false;
                }
                finally {
                }
            });
        }
        sendToAll(message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToAll(this.hub, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToUser(username, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToUser(this.hub, username, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToConnection(connectionId, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToConnection(this.hub, connectionId, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a specific connection is connected to this hub
         *
         * @param connectionId Connection id to check
         * @param options Additional options
         */
        hasConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkConnectionExistence(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Close a specific connection to this hub
         *
         * @param connectionId Connection id to close
         * @param options Additional options
         */
        closeConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.closeClientConnection(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        reason: options.reason
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific user from all groups they are joined to
         * @param userId The user id to remove from all groups
         * @param options Additional options
         */
        removeUserFromAllGroups(userId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromAllGroups(this.hub, userId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular group exists (i.e. has active connections).
         *
         * @param groupName The group name to check for
         * @param options Additional options
         */
        hasGroup(groupName, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkGroupExistence(this.hub, groupName, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular user is connected to this hub.
         *
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUser(username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistence(this.hub, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Add a specific connection to this group
         *
         * @param connectionId The connection id to add to this group
         * @param options Additional options
         */
        addConnectionToGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.addConnectionToGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific connection from this group
         *
         * @param connectionId The connection id to remove from this group
         * @param options Additional options
         */
        removeConnectionFromGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.removeConnectionFromGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Add a user to this group
         *
         * @param username The user name to add
         * @param options Additional options
         */
        addUserToGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.addUserToGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a user is in this group
         *
         * @param groupName The group name to check for
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUserInGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistenceInGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Remove a user from this group
         *
         * @param groupName The group name to check for
         * @param username The user name to remove
         * @param options Additional options
         */
        removeUserFromGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    // FOR now it is still 202, we are changing the service to support 200 soon
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        publish(groupName, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToGroup(groupName, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        verifyResponse(res, successStatus, failureStatus) {
            if (successStatus !== undefined && res._response.status === successStatus) {
                return true;
            }
            if (failureStatus !== undefined && res._response.status === failureStatus) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new msRest.RestError(res._response.bodyAsText, undefined, res._response.status, res._response.request, res._response);
            }
        }
    }

    // For the base64 encoding pieces.
    var alphabet = [
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3',
        '4', '5', '6', '7', '8', '9', '+', '/'
    ];
    var values = {};
    for (var /** @type {?} */ i = 0; i < 64; ++i) {
        values[alphabet[i]] = i;
    }
    /**
     * @param {?} string
     * @return {?}
     */
    function decode(string) {
        var /** @type {?} */ size = string.length;
        if (size === 0) {
            return new Uint8Array(new ArrayBuffer(0));
        }
        if (size % 4 !== 0) {
            throw new Error('Bad length: ' + size);
        }
        if (!string.match(/^[a-zA-Z0-9+/]+={0,2}$/)) {
            throw new Error('Invalid base64 encoded value');
        }
        // Every 4 base64 chars = 24 bits = 3 bytes. But, we also need to figure out
        // padding, if any.
        var /** @type {?} */ bytes = 3 * (size / 4);
        var /** @type {?} */ numPad = 0;
        if (string.charAt(size - 1) === '=') {
            numPad++;
            bytes--;
        }
        if (string.charAt(size - 2) === '=') {
            numPad++;
            bytes--;
        }
        var /** @type {?} */ buffer = new Uint8Array(new ArrayBuffer(bytes));
        var /** @type {?} */ index = 0;
        var /** @type {?} */ bufferIndex = 0;
        var /** @type {?} */ quantum;
        if (numPad > 0) {
            size -= 4; // handle the last one specially
        }
        /* tslint:disable:no-bitwise */
        while (index < size) {
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            // quantum is now a 24-bit value.
            buffer[bufferIndex++] = (quantum >> 16) & 0xff;
            buffer[bufferIndex++] = (quantum >> 8) & 0xff;
            buffer[bufferIndex++] = quantum & 0xff;
            index += 4;
        }
        if (numPad > 0) {
            // if numPad == 1, there is one =, and we have 18 bits with 2 0s at end.
            // if numPad == 2, there is two ==, and we have 12 bits with 4 0s at end.
            // First, grab my quantum.
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4 - numPad; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            if (numPad === 1) {
                // quantum is 18 bits, but really represents two bytes.
                quantum = quantum >> 2;
                buffer[bufferIndex++] = (quantum >> 8) & 0xff;
                buffer[bufferIndex++] = quantum & 0xff;
            }
            else {
                // quantum is 12 bits, but really represents only one byte.
                quantum = quantum >> 4;
                buffer[bufferIndex++] = quantum & 0xff;
            }
        }
        /* tslint:enable:no-bitwise */
        return buffer;
    }

    // Copyright (c) Microsoft Corporation.
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["serverError"] = 0] = "serverError";
        ErrorCode[ErrorCode["userError"] = 1] = "userError";
        ErrorCode[ErrorCode["unauthorized"] = 2] = "unauthorized";
    })(ErrorCode || (ErrorCode = {}));
    class DefaultEventHandler {
        constructor(options) {
            this.options = options;
        }
        onMessage(r) {
            var _a, _b;
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.onUserEvent) === undefined) {
                return undefined;
            }
            return (_b = this.options) === null || _b === void 0 ? void 0 : _b.onUserEvent(r);
        }
        onConnect(r) {
            var _a, _b;
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.onConnect) === undefined) {
                return undefined;
            }
            return (_b = this.options) === null || _b === void 0 ? void 0 : _b.onConnect(r);
        }
        onConnected(r) {
            var _a, _b;
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.onConnected) === undefined) {
                return;
            }
            (_b = this.options) === null || _b === void 0 ? void 0 : _b.onConnected(r);
        }
        onDisconnected(r) {
            var _a, _b;
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.onDisconnected) === undefined) {
                return;
            }
            (_b = this.options) === null || _b === void 0 ? void 0 : _b.onDisconnected(r);
        }
    }
    class ProtocolParser {
        constructor(hub, eventHandler, dumpRequest) {
            this.hub = hub;
            this.eventHandler = eventHandler;
            this.dumpRequest = dumpRequest;
        }
        processNodeHttpRequest(request) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var eventRequest = yield this.convertHttpToEvent(request);
                    return this.getResponse(eventRequest);
                }
                catch (err) {
                    console.error(`Error processing request ${request}: ${err}`);
                    return {
                        error: {
                            code: ErrorCode.serverError,
                            detail: err.message,
                        }
                    };
                }
            });
        }
        getResponse(request) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.eventHandler === undefined) {
                    return;
                }
                const receivedEvent = cloudevents.HTTP.toEvent(request);
                if (this.dumpRequest === true) {
                    console.log(receivedEvent);
                }
                var type = receivedEvent.type.toLowerCase();
                var context = this.GetContext(receivedEvent);
                if (context.hub !== this.hub) {
                    console.warn(`Incoming request is for hub '${this.hub}' while the incoming request is for hub '${context.hub}'`);
                    return;
                }
                // TODO: valid request is a valid cloud event with WebPubSub extension
                if (type === "azure.webpubsub.sys.connect") {
                    var connectRequest = receivedEvent.data;
                    if (!connectRequest) {
                        throw new Error("Data is expected");
                    }
                    connectRequest.context = context;
                    var connectResponse = yield this.eventHandler.onConnect(connectRequest);
                    if (connectRequest) {
                        return {
                            body: JSON.stringify(connectResponse)
                        };
                    }
                    else {
                        return;
                    }
                }
                else if (type === "azure.webpubsub.sys.connected") {
                    var connectedRequest = receivedEvent.data;
                    if (!connectedRequest) {
                        throw new Error("Data is expected");
                    }
                    connectedRequest.context = context;
                    this.eventHandler.onConnected(connectedRequest);
                }
                else if (type === "azure.webpubsub.sys.disconnected") {
                    var disconnectedRequest = receivedEvent.data;
                    if (!disconnectedRequest) {
                        throw new Error("Data is expected");
                    }
                    disconnectedRequest.context = context;
                    this.eventHandler.onDisconnected(disconnectedRequest);
                }
                else if (type.startsWith("azure.webpubsub.user")) {
                    console.log(receivedEvent);
                    var data;
                    if (receivedEvent.data) {
                        data = receivedEvent.data;
                    }
                    else if (receivedEvent.data_base64) {
                        data = decode(receivedEvent.data_base64);
                    }
                    else {
                        throw new Error("empty data payload");
                    }
                    var userRequest = {
                        eventName: context.eventName,
                        context: context,
                        data: data
                    };
                    console.log(userRequest);
                    if (!userRequest) {
                        throw new Error("Data is expected");
                    }
                    userRequest.context = context;
                    return yield this.eventHandler.onMessage(userRequest);
                }
                /* for subprotocol
                else if (type === "azure.webpubsub.sys.publish") {
            
                }  else if (type === "azure.webpubsub.sys.published") {
            
                }  else if (type === "azure.webpubsub.sys.join") {
            
                } else if (type === "azure.webpubsub.sys.joined") {
            
                }  else if (type === "azure.webpubsub.sys.leave") {
            
                } else if (type === "azure.webpubsub.sys.left") {
            
                }
                */
                else {
                    throw new Error("Not supported event: " + type);
                }
            });
        }
        GetContext(ce) {
            var context = {
                signature: ce["signature"],
                userId: ce["userid"],
                hub: ce["hub"],
                connectionId: ce["connectionid"],
                eventName: ce["eventname"]
            };
            // TODO: validation
            return context;
        }
        convertHttpToEvent(request) {
            return __awaiter(this, void 0, void 0, function* () {
                const normalized = {
                    headers: {},
                    body: ''
                };
                if (request.headers) {
                    for (const key in request.headers) {
                        if (Object.prototype.hasOwnProperty.call(request.headers, key)) {
                            const element = request.headers[key];
                            if (element === undefined) {
                                continue;
                            }
                            if (typeof element === 'string') {
                                normalized.headers[key] = element;
                            }
                            else {
                                normalized.headers[key] = element.join(',');
                            }
                        }
                    }
                }
                normalized.body = yield this.readRequestBody(request);
                return normalized;
            });
        }
        readRequestBody(req) {
            return new Promise(function (resolve, reject) {
                var body = "";
                req.on('data', function (chunk) {
                    body += chunk;
                });
                req.on('end', function () {
                    resolve(body);
                });
                // reject on request error
                req.on('error', function (err) {
                    // This is not a "Second reject", just a different sort of failure
                    reject(err);
                });
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * Client for connecting to a SignalR hub
     */
    class WebPubSubServer extends WebPubSubServiceRestClient {
        constructor(connectionString, hub, options) {
            var _a;
            super(connectionString, hub, options);
            /**
             * The SignalR API version being used by this client
             */
            this.apiVersion = "2020-10-01";
            this.hub = hub;
            this._parser = new ProtocolParser(this.hub, new DefaultEventHandler(options), options === null || options === void 0 ? void 0 : options.dumpRequest);
            this.eventHandlerUrl = (_a = options === null || options === void 0 ? void 0 : options.eventHandlerUrl) !== null && _a !== void 0 ? _a : `/api/webpubsub/hubs/${this.hub}`;
        }
        Process(req) {
            return __awaiter(this, void 0, void 0, function* () {
                var result = yield this._parser.getResponse(req);
                if (result === undefined) {
                    return { body: undefined };
                }
                return result;
            });
        }
        handleNodeRequest(request, response) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                if (request.method !== 'POST') {
                    return false;
                }
                if (((_a = request.url) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== this.eventHandlerUrl.toLowerCase()) {
                    return false;
                }
                var result = yield this._parser.processNodeHttpRequest(request);
                if (result === null || result === void 0 ? void 0 : result.body) {
                    if (typeof (result.body) === 'string') {
                        response.setHeader("Content-Type", "text/plain");
                    }
                }
                response.end((_b = result === null || result === void 0 ? void 0 : result.body) !== null && _b !== void 0 ? _b : '');
                return true;
            });
        }
        getMiddleware() {
            const router = express.Router();
            router.use(this.eventHandlerUrl, (req, res) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (req.method !== 'POST') {
                    res.status(400).send('Invalid method ' + req.method);
                    return;
                }
                var result = yield this._parser.processNodeHttpRequest(req);
                if (result === null || result === void 0 ? void 0 : result.body) {
                    if (typeof (result.body) === 'string') {
                        res.type('text');
                    }
                }
                res.end((_a = result === null || result === void 0 ? void 0 : result.body) !== null && _a !== void 0 ? _a : '');
            }));
            return router;
        }
    }

    exports.ConsoleHttpPipelineLogger = ConsoleHttpPipelineLogger;
    exports.WebPubSubServer = WebPubSubServer;
    exports.WebPubSubServiceEndpoint = WebPubSubServiceEndpoint;
    exports.WebPubSubServiceRestClient = WebPubSubServiceRestClient;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=webpubsub.js.map
