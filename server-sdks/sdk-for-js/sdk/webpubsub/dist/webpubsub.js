/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('url'), require('cloudevents'), require('express'), require('@azure/ms-rest-azure-js'), require('@azure/core-http'), require('jsonwebtoken')) :
    typeof define === 'function' && define.amd ? define(['exports', 'url', 'cloudevents', 'express', '@azure/ms-rest-azure-js', '@azure/core-http', 'jsonwebtoken'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.WebPubSub = {}), global.url, global.cloudevents, global.express, global.msRestAzure, global.coreHttp, global.jwt));
}(this, (function (exports, url, cloudevents, express, msRestAzureJs, coreHttp, jwt) { 'use strict';

    express = express && Object.prototype.hasOwnProperty.call(express, 'default') ? express['default'] : express;
    jwt = jwt && Object.prototype.hasOwnProperty.call(jwt, 'default') ? jwt['default'] : jwt;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    // For the base64 encoding pieces.
    var alphabet = [
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3',
        '4', '5', '6', '7', '8', '9', '+', '/'
    ];
    var values = {};
    for (var /** @type {?} */ i = 0; i < 64; ++i) {
        values[alphabet[i]] = i;
    }
    /**
     * @param {?} string
     * @return {?}
     */
    function decode(string) {
        var /** @type {?} */ size = string.length;
        if (size === 0) {
            return new Uint8Array(new ArrayBuffer(0));
        }
        if (size % 4 !== 0) {
            throw new Error('Bad length: ' + size);
        }
        if (!string.match(/^[a-zA-Z0-9+/]+={0,2}$/)) {
            throw new Error('Invalid base64 encoded value');
        }
        // Every 4 base64 chars = 24 bits = 3 bytes. But, we also need to figure out
        // padding, if any.
        var /** @type {?} */ bytes = 3 * (size / 4);
        var /** @type {?} */ numPad = 0;
        if (string.charAt(size - 1) === '=') {
            numPad++;
            bytes--;
        }
        if (string.charAt(size - 2) === '=') {
            numPad++;
            bytes--;
        }
        var /** @type {?} */ buffer = new Uint8Array(new ArrayBuffer(bytes));
        var /** @type {?} */ index = 0;
        var /** @type {?} */ bufferIndex = 0;
        var /** @type {?} */ quantum;
        if (numPad > 0) {
            size -= 4; // handle the last one specially
        }
        /* tslint:disable:no-bitwise */
        while (index < size) {
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            // quantum is now a 24-bit value.
            buffer[bufferIndex++] = (quantum >> 16) & 0xff;
            buffer[bufferIndex++] = (quantum >> 8) & 0xff;
            buffer[bufferIndex++] = quantum & 0xff;
            index += 4;
        }
        if (numPad > 0) {
            // if numPad == 1, there is one =, and we have 18 bits with 2 0s at end.
            // if numPad == 2, there is two ==, and we have 12 bits with 4 0s at end.
            // First, grab my quantum.
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4 - numPad; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            if (numPad === 1) {
                // quantum is 18 bits, but really represents two bytes.
                quantum = quantum >> 2;
                buffer[bufferIndex++] = (quantum >> 8) & 0xff;
                buffer[bufferIndex++] = quantum & 0xff;
            }
            else {
                // quantum is 12 bits, but really represents only one byte.
                quantum = quantum >> 4;
                buffer[bufferIndex++] = quantum & 0xff;
            }
        }
        /* tslint:enable:no-bitwise */
        return buffer;
    }

    // Copyright (c) Microsoft Corporation.
    (function (ErrorCode) {
        /**
         * Unauthorized response to service using 401.
         */
        ErrorCode[ErrorCode["unauthorized"] = 401] = "unauthorized";
        /**
         * Server error response to service using 500.
         */
        ErrorCode[ErrorCode["serverError"] = 500] = "serverError";
        /**
         * User error response to service using 400.
         */
        ErrorCode[ErrorCode["userError"] = 400] = "userError";
    })(exports.ErrorCode || (exports.ErrorCode = {}));
    (function (PayloadDataType) {
        /**
         * The binary format.
         */
        PayloadDataType[PayloadDataType["binary"] = 0] = "binary";
        /**
         * The plain text format.
         */
        PayloadDataType[PayloadDataType["text"] = 1] = "text";
        /**
         * The JSON format.
         */
        PayloadDataType[PayloadDataType["json"] = 2] = "json";
    })(exports.PayloadDataType || (exports.PayloadDataType = {}));

    // Copyright (c) Microsoft Corporation.
    class CloudEventsDispatcher {
        constructor(hub, eventHandler, dumpRequest) {
            this.hub = hub;
            this.eventHandler = eventHandler;
            this.dumpRequest = dumpRequest;
        }
        processRequest(request, response) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.eventHandler) {
                    response.end();
                    return;
                }
                try {
                    var eventRequest = yield this.convertHttpToEvent(request);
                    var eventResponse = yield this.getResponse(eventRequest);
                    if (!eventResponse) {
                        // we consider no response as 200 valid response
                        response.end();
                        return;
                    }
                    if (eventResponse.error) {
                        switch (eventResponse.error.code) {
                            case exports.ErrorCode.userError:
                                response.statusCode = 400;
                                break;
                            case exports.ErrorCode.unauthorized:
                                response.statusCode = 401;
                                break;
                            default:
                                response.statusCode = 500;
                                break;
                        }
                        response.end((_a = eventResponse.error.detail) !== null && _a !== void 0 ? _a : "");
                        return;
                    }
                    if (eventResponse === null || eventResponse === void 0 ? void 0 : eventResponse.payload) {
                        if (eventResponse.payload.dataType === exports.PayloadDataType.binary) {
                            response.setHeader("Content-Type", "application/octet-stream");
                        }
                        else if (eventResponse.payload.dataType === exports.PayloadDataType.json) {
                            response.setHeader("Content-Type", "application/json");
                        }
                        else {
                            response.setHeader("Content-Type", "text/plain; charset=utf-8");
                        }
                        response.end((_c = (_b = eventResponse.payload) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : "");
                    }
                }
                catch (err) {
                    console.error(`Error processing request ${request}: ${err}`);
                    response.statusCode = 500;
                    response.end(err.message);
                }
            });
        }
        getResponse(request) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const receivedEvent = cloudevents.HTTP.toEvent(request);
                if (this.dumpRequest === true) {
                    console.log(receivedEvent);
                }
                var type = receivedEvent.type.toLowerCase();
                var context = this.GetContext(receivedEvent, request.headers.host);
                if (context.hub !== this.hub) {
                    // it is possible when multiple hubs share the same handler
                    console.info(`Incoming request is for hub '${this.hub}' while the incoming request is for hub '${context.hub}'`);
                    return;
                }
                // TODO: valid request is a valid cloud event with WebPubSub extension
                if (type === "azure.webpubsub.sys.connect") {
                    if (!((_a = this.eventHandler) === null || _a === void 0 ? void 0 : _a.onConnect)) {
                        // 401 if onConnect is not configured
                        return {
                            error: {
                                code: exports.ErrorCode.unauthorized
                            }
                        };
                    }
                    var connectRequest = receivedEvent.data;
                    if (!connectRequest) {
                        throw new Error("Data is expected");
                    }
                    connectRequest.context = context;
                    var connectResponse = yield this.eventHandler.onConnect(connectRequest);
                    if (connectRequest) {
                        return {
                            payload: {
                                data: JSON.stringify(connectResponse),
                                dataType: exports.PayloadDataType.json
                            }
                        };
                    }
                    else {
                        // what is the differnce between not configure and not return? there is no such definition in C#..
                        // 401 if onConnect is not configured
                        return {
                            error: {
                                code: exports.ErrorCode.unauthorized
                            }
                        };
                    }
                }
                else if (type === "azure.webpubsub.sys.connected") {
                    if (!((_b = this.eventHandler) === null || _b === void 0 ? void 0 : _b.onConnected)) {
                        return;
                    }
                    var connectedRequest = receivedEvent.data;
                    if (!connectedRequest) {
                        throw new Error("Data is expected");
                    }
                    connectedRequest.context = context;
                    this.eventHandler.onConnected(connectedRequest);
                }
                else if (type === "azure.webpubsub.sys.disconnected") {
                    if (!((_c = this.eventHandler) === null || _c === void 0 ? void 0 : _c.onDisconnected)) {
                        return;
                    }
                    var disconnectedRequest = receivedEvent.data;
                    if (!disconnectedRequest) {
                        throw new Error("Data is expected");
                    }
                    disconnectedRequest.context = context;
                    this.eventHandler.onDisconnected(disconnectedRequest);
                }
                else if (type.startsWith("azure.webpubsub.user")) {
                    if (!((_d = this.eventHandler) === null || _d === void 0 ? void 0 : _d.onUserEvent)) {
                        return;
                    }
                    var data;
                    var dataType = exports.PayloadDataType.binary;
                    if (receivedEvent.data) {
                        data = receivedEvent.data;
                        dataType =
                            receivedEvent.datacontenttype === "application/json"
                                ? exports.PayloadDataType.json
                                : exports.PayloadDataType.text;
                    }
                    else if (receivedEvent.data_base64) {
                        data = decode(receivedEvent.data_base64);
                    }
                    else {
                        throw new Error("empty data payload");
                    }
                    var userRequest = {
                        context: context,
                        payload: {
                            data: data,
                            dataType: dataType
                        }
                    };
                    if (!userRequest) {
                        throw new Error("Data is expected");
                    }
                    userRequest.context = context;
                    return yield this.eventHandler.onUserEvent(userRequest);
                }
                else {
                    throw new Error("Not supported event: " + type);
                }
                return;
            });
        }
        GetContext(ce, host) {
            var context = {
                signature: ce["signature"],
                userId: ce["userid"],
                hub: ce["hub"],
                connectionId: ce["connectionid"],
                eventName: ce["eventname"],
                host: host
            };
            // TODO: validation
            return context;
        }
        convertHttpToEvent(request) {
            return __awaiter(this, void 0, void 0, function* () {
                const normalized = {
                    headers: {},
                    body: ""
                };
                if (request.headers) {
                    for (const key in request.headers) {
                        if (Object.prototype.hasOwnProperty.call(request.headers, key)) {
                            const element = request.headers[key];
                            if (element === undefined) {
                                continue;
                            }
                            if (typeof element === "string") {
                                normalized.headers[key] = element;
                            }
                            else {
                                normalized.headers[key] = element.join(",");
                            }
                        }
                    }
                }
                normalized.body = yield this.readRequestBody(request);
                return normalized;
            });
        }
        readRequestBody(req) {
            return new Promise(function (resolve, reject) {
                var body = "";
                req.on("data", function (chunk) {
                    body += chunk;
                });
                req.on("end", function () {
                    resolve(body);
                });
                // reject on request error
                req.on("error", function (err) {
                    // This is not a "Second reject", just a different sort of failure
                    reject(err);
                });
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * The handler to handle incoming CloudEvents messages
     */
    class WebPubSubCloudEventsHandler {
        /**
         * Creates an instance of a WebPubSubCloudEventsHandler for handling incoming CloudEvents messages.
         *
         * Example usage:
         * ```ts
         * import express from "express";
         * import { WebPubSubCloudEventsHandler } from "@azure/web-pubsub-express";
         * const endpoint = "https://xxxx.webpubsubdev.azure.com"
         * const handler = new WebPubSubCloudEventsHandler('chat', [ endpoint ] {
         *   onConnect: async connectRequest => {
         *     console.log(JSON.stringify(connectRequest));
         *     return {};
         *   },
         *   onConnected: async connectedRequest => {
         *     console.log(JSON.stringify(connectedRequest));
         *   },
         *   onUserEvent: async userRequest => {
         *     console.log(JSON.stringify(userRequest));
         *     return {
         *      payload: {
         *        data: "Hey " + userRequest.payload.data,
         *        dataType: userRequest.payload.dataType
         *      }
         *    };
         *  },
         * });
         * ```
         *
         * @param hub The name of the hub to listen to
         * @param allowedEndpoints The allowed endpoints for the incoming CloudEvents request
         * @param options Options to configure the event handler
         */
        constructor(hub, allowedEndpoints, options) {
            var _a;
            this.hub = hub;
            const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : `/api/webpubsub/hubs/${hub}`;
            this.path = path.endsWith("/") ? path : path + "/";
            this._allowedOrigins = allowedEndpoints.map((endpoint) => endpoint === "*" ? "*" : (new url.URL(endpoint).host));
            this._cloudEventsHandler = new CloudEventsDispatcher(this.hub, options, options === null || options === void 0 ? void 0 : options.dumpRequest);
        }
        /**
         * Get the middleware to be used in express
         */
        getMiddleware() {
            const router = express.Router();
            router.options(this.path, (request, response) => this.handleAbuseProtectionRequests(request, response));
            router.post(this.path, (request, response) => this._cloudEventsHandler.processRequest(request, response));
            return router;
        }
        handleAbuseProtectionRequests(request, response) {
            if (request.headers["webhook-request-origin"]) {
                response.setHeader("WebHook-Allowed-Origin", this._allowedOrigins);
            }
            else {
                console.log(`Invalid abuse protection request ${request}`);
                response.statusCode = 400;
            }
            response.end();
            return true;
        }
    }

    const $host = {
        parameterPath: "$host",
        mapper: {
            serializedName: "$host",
            required: true,
            type: {
                name: "String"
            }
        },
        skipEncoding: true
    };
    const apiVersion = {
        parameterPath: "apiVersion",
        mapper: {
            defaultValue: "2020-10-01",
            isConstant: true,
            serializedName: "api-version",
            type: {
                name: "String"
            }
        }
    };
    const contentType = {
        parameterPath: "contentType",
        mapper: {
            defaultValue: "application/octet-stream",
            isConstant: true,
            serializedName: "Content-Type",
            type: {
                name: "String"
            }
        }
    };
    const payloadMessage = {
        parameterPath: "payloadMessage",
        mapper: {
            serializedName: "payloadMessage",
            required: true,
            type: {
                name: "Stream"
            }
        }
    };
    const contentType1 = {
        parameterPath: "contentType",
        mapper: {
            defaultValue: "text/plain",
            isConstant: true,
            serializedName: "Content-Type",
            type: {
                name: "String"
            }
        }
    };
    const payloadMessage1 = {
        parameterPath: "payloadMessage",
        mapper: {
            serializedName: "payloadMessage",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const contentType2 = {
        parameterPath: "contentType",
        mapper: {
            defaultValue: "application/json",
            isConstant: true,
            serializedName: "Content-Type",
            type: {
                name: "String"
            }
        }
    };
    const payloadMessage2 = {
        parameterPath: "payloadMessage",
        mapper: {
            serializedName: "payloadMessage",
            required: true,
            type: {
                name: "Stream"
            }
        }
    };
    const hub = {
        parameterPath: "hub",
        mapper: {
            serializedName: "hub",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const excluded = {
        parameterPath: ["options", "excluded"],
        mapper: {
            serializedName: "excluded",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "String"
                    }
                }
            }
        },
        collectionFormat: coreHttp.QueryCollectionFormat.Multi
    };
    const connectionId = {
        parameterPath: "connectionId",
        mapper: {
            serializedName: "connectionId",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const reason = {
        parameterPath: ["options", "reason"],
        mapper: {
            serializedName: "reason",
            type: {
                name: "String"
            }
        }
    };
    const group = {
        parameterPath: "group",
        mapper: {
            serializedName: "group",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const userId = {
        parameterPath: "userId",
        mapper: {
            serializedName: "userId",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const permission = {
        parameterPath: "permission",
        mapper: {
            serializedName: "permission",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const targetName = {
        parameterPath: ["options", "targetName"],
        mapper: {
            serializedName: "targetName",
            type: {
                name: "String"
            }
        }
    };
    const permission1 = {
        parameterPath: "permission",
        mapper: {
            serializedName: "permission",
            required: true,
            type: {
                name: "String"
            }
        }
    };
    const permission2 = {
        parameterPath: "permission",
        mapper: {
            serializedName: "permission",
            required: true,
            type: {
                name: "String"
            }
        }
    };

    /**
     * Class representing a HealthApi.
     */
    class HealthApi {
        /**
         * Initialize a new instance of the class HealthApi class.
         * @param client Reference to the service client
         */
        constructor(client) {
            this.client = client;
        }
        /**
         * Get service health status.
         * @param options The options parameters.
         */
        getHealthStatus(options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ options: operationOptions }, getHealthStatusOperationSpec);
        }
    }
    // Operation Specifications
    const serializer = new coreHttp.Serializer({}, /* isXml */ false);
    const getHealthStatusOperationSpec = {
        path: "/api/health",
        httpMethod: "HEAD",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [$host],
        serializer
    };

    /**
     * Class representing a WebPubSub.
     */
    class WebPubSub {
        /**
         * Initialize a new instance of the class WebPubSub class.
         * @param client Reference to the service client
         */
        constructor(client) {
            this.client = client;
        }
        /**
         * Broadcast content inside request body to all the connected client connections.
         * @param args Includes all the parameters for this operation.
         */
        sendToAll(...args) {
            let operationSpec;
            let operationArguments;
            if (args[1] === "application/octet-stream") {
                operationSpec = sendToAll$binaryOperationSpec;
                operationArguments = {
                    hub: args[0],
                    contentType: args[1],
                    payloadMessage: args[2],
                    options: args[3]
                };
            }
            else if (args[1] === "text/plain") {
                operationSpec = sendToAll$textOperationSpec;
                operationArguments = {
                    hub: args[0],
                    contentType: args[1],
                    payloadMessage: args[2],
                    options: args[3]
                };
            }
            else if (args[1] === "application/json") {
                operationSpec = sendToAll$jsonOperationSpec;
                operationArguments = {
                    hub: args[0],
                    contentType: args[1],
                    payloadMessage: args[2],
                    options: args[3]
                };
            }
            else {
                throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
            }
            return this.client.sendOperationRequest(operationArguments, operationSpec);
        }
        /**
         * Check if the connection with the given connectionId exists.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param connectionId The connection Id.
         * @param options The options parameters.
         */
        checkConnectionExistence(hub, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, connectionId, options: operationOptions }, checkConnectionExistenceOperationSpec);
        }
        /**
         * Close the client connection.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param connectionId Target connection Id.
         * @param options The options parameters.
         */
        closeClientConnection(hub, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, connectionId, options: operationOptions }, closeClientConnectionOperationSpec);
        }
        /**
         * Send content inside request body to the specific connection.
         * @param args Includes all the parameters for this operation.
         */
        sendToConnection(...args) {
            let operationSpec;
            let operationArguments;
            if (args[2] === "application/octet-stream") {
                operationSpec = sendToConnection$binaryOperationSpec;
                operationArguments = {
                    hub: args[0],
                    connectionId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "text/plain") {
                operationSpec = sendToConnection$textOperationSpec;
                operationArguments = {
                    hub: args[0],
                    connectionId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "application/json") {
                operationSpec = sendToConnection$jsonOperationSpec;
                operationArguments = {
                    hub: args[0],
                    connectionId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else {
                throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
            }
            return this.client.sendOperationRequest(operationArguments, operationSpec);
        }
        /**
         * Check if there are any client connections inside the given group
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param options The options parameters.
         */
        checkGroupExistence(hub, group, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, options: operationOptions }, checkGroupExistenceOperationSpec);
        }
        /**
         * Send content inside request body to a group of connections.
         * @param args Includes all the parameters for this operation.
         */
        sendToGroup(...args) {
            let operationSpec;
            let operationArguments;
            if (args[2] === "application/octet-stream") {
                operationSpec = sendToGroup$binaryOperationSpec;
                operationArguments = {
                    hub: args[0],
                    group: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "text/plain") {
                operationSpec = sendToGroup$textOperationSpec;
                operationArguments = {
                    hub: args[0],
                    group: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "application/json") {
                operationSpec = sendToGroup$jsonOperationSpec;
                operationArguments = {
                    hub: args[0],
                    group: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else {
                throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
            }
            return this.client.sendOperationRequest(operationArguments, operationSpec);
        }
        /**
         * Add a connection to the target group.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param connectionId Target connection Id
         * @param options The options parameters.
         */
        addConnectionToGroup(hub, group, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, connectionId, options: operationOptions }, addConnectionToGroupOperationSpec);
        }
        /**
         * Remove a connection from the target group.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param connectionId Target connection Id.
         * @param options The options parameters.
         */
        removeConnectionFromGroup(hub, group, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, connectionId, options: operationOptions }, removeConnectionFromGroupOperationSpec);
        }
        /**
         * Check if there are any client connections connected for the given user.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param userId Target user Id.
         * @param options The options parameters.
         */
        checkUserExistence(hub, userId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, userId, options: operationOptions }, checkUserExistenceOperationSpec);
        }
        /**
         * Send content inside request body to the specific user.
         * @param args Includes all the parameters for this operation.
         */
        sendToUser(...args) {
            let operationSpec;
            let operationArguments;
            if (args[2] === "application/octet-stream") {
                operationSpec = sendToUser$binaryOperationSpec;
                operationArguments = {
                    hub: args[0],
                    userId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "text/plain") {
                operationSpec = sendToUser$textOperationSpec;
                operationArguments = {
                    hub: args[0],
                    userId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else if (args[2] === "application/json") {
                operationSpec = sendToUser$jsonOperationSpec;
                operationArguments = {
                    hub: args[0],
                    userId: args[1],
                    contentType: args[2],
                    payloadMessage: args[3],
                    options: args[4]
                };
            }
            else {
                throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
            }
            return this.client.sendOperationRequest(operationArguments, operationSpec);
        }
        /**
         * Check whether a user exists in the target group.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param userId Target user Id.
         * @param options The options parameters.
         */
        checkUserExistenceInGroup(hub, group, userId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, userId, options: operationOptions }, checkUserExistenceInGroupOperationSpec);
        }
        /**
         * Add a user to the target group.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param userId Target user Id.
         * @param options The options parameters.
         */
        addUserToGroup(hub, group, userId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, userId, options: operationOptions }, addUserToGroupOperationSpec);
        }
        /**
         * Remove a user from the target group.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param group Target group name, which length should be greater than 0 and less than 1025.
         * @param userId Target user Id.
         * @param options The options parameters.
         */
        removeUserFromGroup(hub, group, userId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, group, userId, options: operationOptions }, removeUserFromGroupOperationSpec);
        }
        /**
         * Remove a user from all groups.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param userId Target user Id.
         * @param options The options parameters.
         */
        removeUserFromAllGroups(hub, userId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, userId, options: operationOptions }, removeUserFromAllGroupsOperationSpec);
        }
        /**
         * Grant permission to the connection.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
         * @param connectionId Target connection Id.
         * @param options The options parameters.
         */
        grantPermission(hub, permission, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, permission, connectionId, options: operationOptions }, grantPermissionOperationSpec);
        }
        /**
         * Revoke permission for the connection.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
         * @param connectionId Target connection Id.
         * @param options The options parameters.
         */
        revokePermission(hub, permission, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, permission, connectionId, options: operationOptions }, revokePermissionOperationSpec);
        }
        /**
         * Check if a connection have permission to the specific action.
         * @param hub Target hub name, which should start with alphabetic characters and only contain
         *            alpha-numeric characters or underscore.
         * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
         * @param connectionId Target connection Id.
         * @param options The options parameters.
         */
        checkPermission(hub, permission, connectionId, options) {
            const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
            return this.client.sendOperationRequest({ hub, permission, connectionId, options: operationOptions }, checkPermissionOperationSpec);
        }
    }
    // Operation Specifications
    const serializer$1 = new coreHttp.Serializer({}, /* isXml */ false);
    const sendToAll$binaryOperationSpec = {
        path: "/api/hubs/{hub}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub],
        headerParameters: [contentType],
        mediaType: "binary",
        serializer: serializer$1
    };
    const sendToAll$textOperationSpec = {
        path: "/api/hubs/{hub}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage1,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub],
        headerParameters: [contentType1],
        mediaType: "text",
        serializer: serializer$1
    };
    const sendToAll$jsonOperationSpec = {
        path: "/api/hubs/{hub}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage2,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub],
        headerParameters: [contentType2],
        mediaType: "json",
        serializer: serializer$1
    };
    const checkConnectionExistenceOperationSpec = {
        path: "/api/hubs/{hub}/connections/{connectionId}",
        httpMethod: "HEAD",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, connectionId],
        serializer: serializer$1
    };
    const closeClientConnectionOperationSpec = {
        path: "/api/hubs/{hub}/connections/{connectionId}",
        httpMethod: "DELETE",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion, reason],
        urlParameters: [$host, hub, connectionId],
        serializer: serializer$1
    };
    const sendToConnection$binaryOperationSpec = {
        path: "/api/hubs/{hub}/connections/{connectionId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, connectionId],
        headerParameters: [contentType],
        mediaType: "binary",
        serializer: serializer$1
    };
    const sendToConnection$textOperationSpec = {
        path: "/api/hubs/{hub}/connections/{connectionId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage1,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, connectionId],
        headerParameters: [contentType1],
        mediaType: "text",
        serializer: serializer$1
    };
    const sendToConnection$jsonOperationSpec = {
        path: "/api/hubs/{hub}/connections/{connectionId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage2,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, connectionId],
        headerParameters: [contentType2],
        mediaType: "json",
        serializer: serializer$1
    };
    const checkGroupExistenceOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}",
        httpMethod: "HEAD",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, group],
        serializer: serializer$1
    };
    const sendToGroup$binaryOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub, group],
        headerParameters: [contentType],
        mediaType: "binary",
        serializer: serializer$1
    };
    const sendToGroup$textOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage1,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub, group],
        headerParameters: [contentType1],
        mediaType: "text",
        serializer: serializer$1
    };
    const sendToGroup$jsonOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage2,
        queryParameters: [apiVersion, excluded],
        urlParameters: [$host, hub, group],
        headerParameters: [contentType2],
        mediaType: "json",
        serializer: serializer$1
    };
    const addConnectionToGroupOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        httpMethod: "PUT",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [
            $host,
            hub,
            connectionId,
            group
        ],
        serializer: serializer$1
    };
    const removeConnectionFromGroupOperationSpec = {
        path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        httpMethod: "DELETE",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [
            $host,
            hub,
            connectionId,
            group
        ],
        serializer: serializer$1
    };
    const checkUserExistenceOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}",
        httpMethod: "HEAD",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, userId],
        serializer: serializer$1
    };
    const sendToUser$binaryOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, userId],
        headerParameters: [contentType],
        mediaType: "binary",
        serializer: serializer$1
    };
    const sendToUser$textOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage1,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, userId],
        headerParameters: [contentType1],
        mediaType: "text",
        serializer: serializer$1
    };
    const sendToUser$jsonOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/:send",
        httpMethod: "POST",
        responses: { 202: {}, default: {} },
        requestBody: payloadMessage2,
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, userId],
        headerParameters: [contentType2],
        mediaType: "json",
        serializer: serializer$1
    };
    const checkUserExistenceInGroupOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
        httpMethod: "HEAD",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [
            $host,
            hub,
            group,
            userId
        ],
        serializer: serializer$1
    };
    const addUserToGroupOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
        httpMethod: "PUT",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [
            $host,
            hub,
            group,
            userId
        ],
        serializer: serializer$1
    };
    const removeUserFromGroupOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
        httpMethod: "DELETE",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [
            $host,
            hub,
            group,
            userId
        ],
        serializer: serializer$1
    };
    const removeUserFromAllGroupsOperationSpec = {
        path: "/api/hubs/{hub}/users/{userId}/groups",
        httpMethod: "DELETE",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion],
        urlParameters: [$host, hub, userId],
        serializer: serializer$1
    };
    const grantPermissionOperationSpec = {
        path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        httpMethod: "PUT",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion, targetName],
        urlParameters: [
            $host,
            hub,
            connectionId,
            permission
        ],
        serializer: serializer$1
    };
    const revokePermissionOperationSpec = {
        path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        httpMethod: "DELETE",
        responses: { 200: {}, default: {} },
        queryParameters: [apiVersion, targetName],
        urlParameters: [
            $host,
            hub,
            connectionId,
            permission1
        ],
        serializer: serializer$1
    };
    const checkPermissionOperationSpec = {
        path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        httpMethod: "HEAD",
        responses: { 200: {}, 404: {}, default: {} },
        queryParameters: [apiVersion, targetName],
        urlParameters: [
            $host,
            hub,
            connectionId,
            permission2
        ],
        serializer: serializer$1
    };

    const packageName = "@azure/webpubsub";
    const packageVersion = "1.0.0";
    class WebPubSubServiceClientContext extends coreHttp.ServiceClient {
        /**
         * Initializes a new instance of the WebPubSubServiceClientContext class.
         * @param credentials Subscription credentials which uniquely identify client subscription.
         * @param $host server parameter
         * @param options The parameter options
         */
        constructor(credentials, $host, options) {
            if (credentials === undefined) {
                throw new Error("'credentials' cannot be null");
            }
            if ($host === undefined) {
                throw new Error("'$host' cannot be null");
            }
            // Initializing default values for options
            if (!options) {
                options = {};
            }
            if (!options.userAgent) {
                const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
                options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
            }
            super(credentials, options);
            this.requestContentType = "application/json; charset=utf-8";
            this.baseUri = options.endpoint || "{$host}";
            // Parameter assignments
            this.$host = $host;
            // Assigning values to Constant parameters
            this.apiVersion = options.apiVersion || "2020-10-01";
        }
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    class WebPubSubServiceClient extends WebPubSubServiceClientContext {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, host, options) {
            super(credentials, host, options);
            this.healthApi = new HealthApi(this);
            this.webPubSubApi = new WebPubSub(this);
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubKeyCredentials {
        /**
         * Creates a new TokenCredentials object.
         *
         * @constructor
         * @param {string} key The key.
         */
        constructor(key) {
            this.key = key;
            if (!key) {
                throw new Error("token cannot be null or undefined.");
            }
        }
        /**
         * Signs a request with the Authentication header.
         *
         * @param {WebResourceLike} webResource The WebResourceLike to be signed.
         * @return {Promise<WebResourceLike>} The signed request object.
         */
        signRequest(webResource) {
            var _a;
            if (!webResource.headers)
                webResource.headers = new coreHttp.HttpHeaders();
            var url = new URL((_a = webResource.url + webResource.query) !== null && _a !== void 0 ? _a : '');
            url.port = '';
            const audience = url.toString();
            webResource.headers.set("Authorization", "Bearer " +
                jwt.sign({}, this.key, {
                    audience: audience,
                    expiresIn: "1h",
                    algorithm: "HS256"
                }));
            return Promise.resolve(webResource);
        }
    }

    // Copyright (c) Microsoft Corporation.
    class ConsoleHttpPipelineLogger {
        /**
         * Create a new ConsoleHttpPipelineLogger.
         * @param minimumLogLevel The log level threshold for what logs will be logged.
         */
        constructor(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
        }
        /**
         * Log the provided message.
         * @param logLevel The HttpLogDetailLevel associated with this message.
         * @param message The message to log.
         */
        log(logLevel, message) {
            const logMessage = `${coreHttp.HttpPipelineLogLevel[logLevel]}: ${message}`;
            switch (logLevel) {
                case coreHttp.HttpPipelineLogLevel.ERROR:
                    console.error(logMessage);
                    break;
                case coreHttp.HttpPipelineLogLevel.WARNING:
                    console.warn(logMessage);
                    break;
                case coreHttp.HttpPipelineLogLevel.INFO:
                    console.log(logMessage);
                    break;
            }
        }
    }
    /**
     * Client for connecting to a SignalR hub
     */
    class WebPubSubServiceClient$1 {
        constructor(conn, hub, options) {
            /**
             * The SignalR API version being used by this client
             */
            this.apiVersion = "2020-10-01";
            const parsedCs = parseConnectionString(conn);
            this._endpoint = parsedCs.endpoint;
            this.credential = parsedCs.credential;
            this.hub = hub;
            this.client = new WebPubSubServiceClient(this.credential, this._endpoint, {
                //httpPipelineLogger: options?.dumpRequest ? new ConsoleHttpPipelineLogger(HttpPipelineLogLevel.INFO) : undefined,
                requestPolicyFactories: (options === null || options === void 0 ? void 0 : options.dumpRequest) ? this.getFactoryWithLogPolicy : undefined,
            });
            this.sender = new WebPubSub(this.client);
        }
        /**
         * Auth the client connection with userId and custom claims if any
         * @param options The options that the client has
         */
        getAuthenticationToken(options) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const endpoint = this._endpoint.endsWith("/") ? this._endpoint : this._endpoint + "/";
                const key = this.credential.key;
                const hub = this.hub;
                var clientEndpoint = endpoint.replace(/(http)(s?:\/\/)/gi, "ws$2");
                var clientUrl = `${clientEndpoint}client/hubs/${hub}`;
                const audience = `${endpoint}client/hubs/${hub}`;
                var payload = (_a = options === null || options === void 0 ? void 0 : options.claims) !== null && _a !== void 0 ? _a : {};
                var signOptions = {
                    audience: audience,
                    expiresIn: "1h",
                    algorithm: "HS256"
                };
                if (options === null || options === void 0 ? void 0 : options.userId) {
                    signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
                }
                const token = jwt.sign(payload, key, signOptions);
                const url = `${clientUrl}?access_token=${token}`;
                return {
                    baseUrl: clientUrl,
                    token: jwt.sign(payload, key, signOptions),
                    url: url
                };
            });
        }
        getFactoryWithLogPolicy(defaultRequestPolicyFactories) {
            defaultRequestPolicyFactories.push(coreHttp.logPolicy());
        }
        /**
         * Check if the service is healthy
         *
         * @param options Additional options
         */
        serviceIsHealthy(options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.client.healthApi.getHealthStatus({});
                    return true;
                }
                catch (_a) {
                    return false;
                }
                finally {
                }
            });
        }
        hasPermission(connectionId, permission, group, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkPermission(this.hub, permission, connectionId, {
                        targetName: group
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        grantPermission(connectionId, permission, group, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.grantPermission(this.hub, permission, connectionId, {
                        targetName: group
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        revokePermission(connectionId, permission, group, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.revokePermission(this.hub, permission, connectionId, {
                        targetName: group
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        sendToAll(message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = typeof message === "string" ?
                        (options.plainText ?
                            yield this.sender.sendToAll(this.hub, "text/plain", message, {
                                excluded: options.excludedConnections
                            }) :
                            yield this.sender.sendToAll(this.hub, "application/json", message, {
                                excluded: options.excludedConnections
                            })) :
                        yield this.sender.sendToAll(this.hub, "application/octet-stream", message, {
                            excluded: options.excludedConnections
                        });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToUser(username, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = typeof message === "string" ?
                        (options.plainText ?
                            yield this.sender.sendToUser(this.hub, username, "text/plain", message, {}) : yield this.sender.sendToUser(this.hub, username, "application/json", message, {}))
                        :
                            yield this.sender.sendToUser(this.hub, username, "application/octet-stream", message, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToConnection(connectionId, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = typeof message === "string" ?
                        (options.plainText ?
                            yield this.sender.sendToConnection(this.hub, connectionId, "text/plain", message, {}) : yield this.sender.sendToConnection(this.hub, connectionId, "application/json", message, {})) :
                        yield this.sender.sendToConnection(this.hub, connectionId, "application/octet-stream", message, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a specific connection is connected to this hub
         *
         * @param connectionId Connection id to check
         * @param options Additional options
         */
        hasConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkConnectionExistence(this.hub, connectionId, {});
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Close a specific connection to this hub
         *
         * @param connectionId Connection id to close
         * @param options Additional options
         */
        closeConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.closeClientConnection(this.hub, connectionId, {
                        reason: options.reason
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific user from all groups they are joined to
         * @param userId The user id to remove from all groups
         * @param options Additional options
         */
        removeUserFromAllGroups(userId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromAllGroups(this.hub, userId, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular group exists (i.e. has active connections).
         *
         * @param groupName The group name to check for
         * @param options Additional options
         */
        hasGroup(groupName, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkGroupExistence(this.hub, groupName, {});
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular user is connected to this hub.
         *
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUser(username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistence(this.hub, username, {});
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Add a specific connection to this group
         *
         * @param connectionId The connection id to add to this group
         * @param options Additional options
         */
        addConnectionToGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.addConnectionToGroup(this.hub, groupName, connectionId, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific connection from this group
         *
         * @param connectionId The connection id to remove from this group
         * @param options Additional options
         */
        removeConnectionFromGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.removeConnectionFromGroup(this.hub, groupName, connectionId, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Add a user to this group
         *
         * @param username The user name to add
         * @param options Additional options
         */
        addUserToGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.addUserToGroup(this.hub, groupName, username, {});
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a user is in this group
         *
         * @param groupName The group name to check for
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUserInGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistenceInGroup(this.hub, groupName, username, {});
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Remove a user from this group
         *
         * @param groupName The group name to check for
         * @param username The user name to remove
         * @param options Additional options
         */
        removeUserFromGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromGroup(this.hub, groupName, username, {});
                    // FOR now it is still 202, we are changing the service to support 200 soon
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        publish(groupName, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToGroup(this.hub, groupName, "application/octet-stream", message, {
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        verifyResponse(res, successStatus, failureStatus) {
            if (successStatus !== undefined && res._response.status === successStatus) {
                return true;
            }
            if (failureStatus !== undefined && res._response.status === failureStatus) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreHttp.RestError(res._response.bodyAsText, undefined, res._response.status, res._response.request, res._response);
            }
        }
    }
    function parseConnectionString(conn) {
        const em = /Endpoint=(.*?)(;|$)/g.exec(conn);
        if (!em)
            throw new TypeError("connection string missing endpoint");
        const endpointPart = em[1];
        const km = /AccessKey=(.*?)(;|$)/g.exec(conn);
        if (!km)
            throw new Error("connection string missing access key");
        const key = km[1];
        const credential = new WebPubSubKeyCredentials(key);
        const pm = /Port=(.*?)(;|$)/g.exec(conn);
        const port = pm == null ? "" : pm[1];
        const url = new URL(endpointPart);
        url.port = port;
        const endpoint = url.toString();
        url.port = "";
        // todo: Support PORT with audience n stuff.
        // this.audience = url.toString();
        return { credential, endpoint: (endpoint.endsWith("/") ? endpoint : endpoint + "/") };
    }

    exports.ConsoleHttpPipelineLogger = ConsoleHttpPipelineLogger;
    exports.WebPubSubCloudEventsHandler = WebPubSubCloudEventsHandler;
    exports.WebPubSubServiceClient = WebPubSubServiceClient$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=webpubsub.js.map
