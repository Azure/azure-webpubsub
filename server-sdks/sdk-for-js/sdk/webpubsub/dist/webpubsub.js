/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jsonwebtoken'), require('url'), require('cloudevents'), require('express'), require('@azure/ms-rest-azure-js'), require('@azure/ms-rest-js')) :
    typeof define === 'function' && define.amd ? define(['exports', 'jsonwebtoken', 'url', 'cloudevents', 'express', '@azure/ms-rest-azure-js', '@azure/ms-rest-js'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.WebPubSub = {}), global.jwt, global.url, global.cloudevents, global.express, global.msRestAzure, global.msRest));
}(this, (function (exports, jwt, url, cloudevents, express, msRestAzure, msRest) { 'use strict';

    jwt = jwt && Object.prototype.hasOwnProperty.call(jwt, 'default') ? jwt['default'] : jwt;
    express = express && Object.prototype.hasOwnProperty.call(express, 'default') ? express['default'] : express;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubServiceEndpoint {
        /**
         * Creates a new WebPubSubServiceEndpoint object.
         *
         * @constructor
         * @param {string} conn The Connection String.
         * @param {string} hub The Hub
         */
        constructor(conn) {
            this.endpoint = this.getServiceEndpoint(conn);
        }
        clientNegotiate(hub, options) {
            var _a;
            var clientUrl = `${this.endpoint.websocketHost}client/hubs/${hub}`;
            const audience = `${this.endpoint.audience}client/hubs/${hub}`;
            var key = this.endpoint.key;
            var payload = (_a = options === null || options === void 0 ? void 0 : options.claims) !== null && _a !== void 0 ? _a : {};
            var signOptions = {
                audience: audience,
                expiresIn: "1h",
                algorithm: "HS256",
            };
            if (options === null || options === void 0 ? void 0 : options.userId) {
                signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
            }
            return {
                url: clientUrl,
                token: jwt.sign(payload, key, signOptions),
            };
        }
        getServiceEndpoint(conn) {
            var endpoint = this.parseConnectionString(conn);
            if (!endpoint) {
                throw new Error("Invalid connection string: " + conn);
            }
            return endpoint;
        }
        parseConnectionString(conn) {
            const em = /Endpoint=(.*?)(;|$)/g.exec(conn);
            if (!em)
                return null;
            const endpoint = em[1];
            const km = /AccessKey=(.*?)(;|$)/g.exec(conn);
            if (!km)
                return null;
            const key = km[1];
            if (!endpoint || !key)
                return null;
            const pm = /Port=(.*?)(;|$)/g.exec(conn);
            const port = pm == null ? '' : pm[1];
            var url$1 = new url.URL(endpoint);
            var originalProtocol = url$1.protocol;
            url$1.protocol = originalProtocol === 'http:' ? 'ws:' : 'wss:';
            const audience = url$1.toString();
            url$1.port = port;
            var websocketHost = url$1.toString();
            url$1.protocol = originalProtocol;
            return {
                websocketHost: websocketHost,
                serviceUrl: url$1,
                audience: audience,
                key: key,
            };
        }
    }

    // For the base64 encoding pieces.
    var alphabet = [
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3',
        '4', '5', '6', '7', '8', '9', '+', '/'
    ];
    var values = {};
    for (var /** @type {?} */ i = 0; i < 64; ++i) {
        values[alphabet[i]] = i;
    }
    /**
     * @param {?} string
     * @return {?}
     */
    function decode(string) {
        var /** @type {?} */ size = string.length;
        if (size === 0) {
            return new Uint8Array(new ArrayBuffer(0));
        }
        if (size % 4 !== 0) {
            throw new Error('Bad length: ' + size);
        }
        if (!string.match(/^[a-zA-Z0-9+/]+={0,2}$/)) {
            throw new Error('Invalid base64 encoded value');
        }
        // Every 4 base64 chars = 24 bits = 3 bytes. But, we also need to figure out
        // padding, if any.
        var /** @type {?} */ bytes = 3 * (size / 4);
        var /** @type {?} */ numPad = 0;
        if (string.charAt(size - 1) === '=') {
            numPad++;
            bytes--;
        }
        if (string.charAt(size - 2) === '=') {
            numPad++;
            bytes--;
        }
        var /** @type {?} */ buffer = new Uint8Array(new ArrayBuffer(bytes));
        var /** @type {?} */ index = 0;
        var /** @type {?} */ bufferIndex = 0;
        var /** @type {?} */ quantum;
        if (numPad > 0) {
            size -= 4; // handle the last one specially
        }
        /* tslint:disable:no-bitwise */
        while (index < size) {
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            // quantum is now a 24-bit value.
            buffer[bufferIndex++] = (quantum >> 16) & 0xff;
            buffer[bufferIndex++] = (quantum >> 8) & 0xff;
            buffer[bufferIndex++] = quantum & 0xff;
            index += 4;
        }
        if (numPad > 0) {
            // if numPad == 1, there is one =, and we have 18 bits with 2 0s at end.
            // if numPad == 2, there is two ==, and we have 12 bits with 4 0s at end.
            // First, grab my quantum.
            quantum = 0;
            for (var /** @type {?} */ i = 0; i < 4 - numPad; ++i) {
                quantum = (quantum << 6) | values[string.charAt(index + i)];
            }
            if (numPad === 1) {
                // quantum is 18 bits, but really represents two bytes.
                quantum = quantum >> 2;
                buffer[bufferIndex++] = (quantum >> 8) & 0xff;
                buffer[bufferIndex++] = quantum & 0xff;
            }
            else {
                // quantum is 12 bits, but really represents only one byte.
                quantum = quantum >> 4;
                buffer[bufferIndex++] = quantum & 0xff;
            }
        }
        /* tslint:enable:no-bitwise */
        return buffer;
    }

    // Copyright (c) Microsoft Corporation.
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["serverError"] = 0] = "serverError";
        ErrorCode[ErrorCode["userError"] = 1] = "userError";
        ErrorCode[ErrorCode["unauthorized"] = 2] = "unauthorized";
    })(ErrorCode || (ErrorCode = {}));
    var PayloadDataType;
    (function (PayloadDataType) {
        PayloadDataType[PayloadDataType["binary"] = 0] = "binary";
        PayloadDataType[PayloadDataType["text"] = 1] = "text";
        PayloadDataType[PayloadDataType["json"] = 2] = "json";
    })(PayloadDataType || (PayloadDataType = {}));
    class ProtocolParser {
        constructor(hub, eventHandler, dumpRequest) {
            this.hub = hub;
            this.eventHandler = eventHandler;
            this.dumpRequest = dumpRequest;
        }
        processNodeHttpRequest(request, response) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.eventHandler) {
                    response.end();
                    return;
                }
                try {
                    var eventRequest = yield this.convertHttpToEvent(request);
                    var eventResponse = yield this.getResponse(eventRequest);
                    if (!eventResponse) {
                        // we consider no response as 200 valid response
                        response.end();
                        return;
                    }
                    if (eventResponse.error) {
                        switch (eventResponse.error.code) {
                            case ErrorCode.userError:
                                response.statusCode = 400;
                                break;
                            case ErrorCode.unauthorized:
                                response.statusCode = 402;
                                break;
                            default:
                                response.statusCode = 500;
                                break;
                        }
                        response.end((_a = eventResponse.error.detail) !== null && _a !== void 0 ? _a : '');
                        return;
                    }
                    if (eventResponse === null || eventResponse === void 0 ? void 0 : eventResponse.payload) {
                        if (eventResponse.payload.dataType === PayloadDataType.binary) {
                            response.setHeader("Content-Type", "application/octet-stream");
                        }
                        else if (eventResponse.payload.dataType === PayloadDataType.json) {
                            response.setHeader("Content-Type", "application/json");
                        }
                        else {
                            response.setHeader("Content-Type", "text/plain; charset=utf-8");
                        }
                        response.end((_c = (_b = eventResponse.payload) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : '');
                    }
                }
                catch (err) {
                    console.error(`Error processing request ${request}: ${err}`);
                    response.statusCode = 500;
                    response.end(err.message);
                }
            });
        }
        getResponse(request) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const receivedEvent = cloudevents.HTTP.toEvent(request);
                if (this.dumpRequest === true) {
                    console.log(receivedEvent);
                }
                var type = receivedEvent.type.toLowerCase();
                var context = this.GetContext(receivedEvent);
                if (context.hub !== this.hub) {
                    // it is possible when multiple hubs share the same handler
                    console.info(`Incoming request is for hub '${this.hub}' while the incoming request is for hub '${context.hub}'`);
                    return;
                }
                // TODO: valid request is a valid cloud event with WebPubSub extension
                if (type === "azure.webpubsub.sys.connect") {
                    if (!((_a = this.eventHandler) === null || _a === void 0 ? void 0 : _a.onConnect)) {
                        return;
                    }
                    var connectRequest = receivedEvent.data;
                    if (!connectRequest) {
                        throw new Error("Data is expected");
                    }
                    connectRequest.context = context;
                    var connectResponse = yield this.eventHandler.onConnect(connectRequest);
                    if (connectRequest) {
                        return {
                            payload: {
                                data: JSON.stringify(connectResponse),
                                dataType: PayloadDataType.json
                            }
                        };
                    }
                    else {
                        return;
                    }
                }
                else if (type === "azure.webpubsub.sys.connected") {
                    if (!((_b = this.eventHandler) === null || _b === void 0 ? void 0 : _b.onConnected)) {
                        return;
                    }
                    var connectedRequest = receivedEvent.data;
                    if (!connectedRequest) {
                        throw new Error("Data is expected");
                    }
                    connectedRequest.context = context;
                    this.eventHandler.onConnected(connectedRequest);
                }
                else if (type === "azure.webpubsub.sys.disconnected") {
                    if (!((_c = this.eventHandler) === null || _c === void 0 ? void 0 : _c.onDisconnected)) {
                        return;
                    }
                    var disconnectedRequest = receivedEvent.data;
                    if (!disconnectedRequest) {
                        throw new Error("Data is expected");
                    }
                    disconnectedRequest.context = context;
                    this.eventHandler.onDisconnected(disconnectedRequest);
                }
                else if (type.startsWith("azure.webpubsub.user")) {
                    if (!((_d = this.eventHandler) === null || _d === void 0 ? void 0 : _d.onUserEvent)) {
                        return;
                    }
                    var data;
                    var dataType = PayloadDataType.binary;
                    if (receivedEvent.data) {
                        data = receivedEvent.data;
                        dataType = receivedEvent.datacontenttype === 'application/json' ? PayloadDataType.json : PayloadDataType.text;
                    }
                    else if (receivedEvent.data_base64) {
                        data = decode(receivedEvent.data_base64);
                    }
                    else {
                        throw new Error("empty data payload");
                    }
                    var userRequest = {
                        eventName: context.eventName,
                        context: context,
                        payload: {
                            data: data,
                            dataType: dataType
                        }
                    };
                    if (!userRequest) {
                        throw new Error("Data is expected");
                    }
                    userRequest.context = context;
                    return yield this.eventHandler.onUserEvent(userRequest);
                }
                else {
                    throw new Error("Not supported event: " + type);
                }
            });
        }
        GetContext(ce) {
            var context = {
                signature: ce["signature"],
                userId: ce["userid"],
                hub: ce["hub"],
                connectionId: ce["connectionid"],
                eventName: ce["eventname"]
            };
            // TODO: validation
            return context;
        }
        convertHttpToEvent(request) {
            return __awaiter(this, void 0, void 0, function* () {
                const normalized = {
                    headers: {},
                    body: ''
                };
                if (request.headers) {
                    for (const key in request.headers) {
                        if (Object.prototype.hasOwnProperty.call(request.headers, key)) {
                            const element = request.headers[key];
                            if (element === undefined) {
                                continue;
                            }
                            if (typeof element === 'string') {
                                normalized.headers[key] = element;
                            }
                            else {
                                normalized.headers[key] = element.join(',');
                            }
                        }
                    }
                }
                normalized.body = yield this.readRequestBody(request);
                return normalized;
            });
        }
        readRequestBody(req) {
            return new Promise(function (resolve, reject) {
                var body = "";
                req.on('data', function (chunk) {
                    body += chunk;
                });
                req.on('end', function () {
                    resolve(body);
                });
                // reject on request error
                req.on('error', function (err) {
                    // This is not a "Second reject", just a different sort of failure
                    reject(err);
                });
            });
        }
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */
    const CloudError = msRestAzure.CloudErrorMapper;

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const acceptLanguage = {
        parameterPath: "acceptLanguage",
        mapper: {
            serializedName: "accept-language",
            defaultValue: 'en-US',
            type: {
                name: "String"
            }
        }
    };
    const apiVersion = {
        parameterPath: [
            "options",
            "apiVersion"
        ],
        mapper: {
            serializedName: "api-version",
            defaultValue: '2020-10-01',
            type: {
                name: "String"
            }
        }
    };
    const connectionId = {
        parameterPath: "connectionId",
        mapper: {
            required: true,
            serializedName: "connectionId",
            type: {
                name: "String"
            }
        }
    };
    const excluded = {
        parameterPath: [
            "options",
            "excluded"
        ],
        mapper: {
            serializedName: "excluded",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "String"
                    }
                }
            }
        },
        collectionFormat: msRest.QueryCollectionFormat.Multi
    };
    const group0 = {
        parameterPath: "group",
        mapper: {
            required: true,
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const group1 = {
        parameterPath: [
            "options",
            "group"
        ],
        mapper: {
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const hub = {
        parameterPath: "hub",
        mapper: {
            required: true,
            serializedName: "hub",
            type: {
                name: "String"
            }
        }
    };
    const id = {
        parameterPath: "id",
        mapper: {
            required: true,
            serializedName: "id",
            type: {
                name: "String"
            }
        }
    };
    const permission = {
        parameterPath: "permission",
        mapper: {
            required: true,
            serializedName: "permission",
            type: {
                name: "String"
            }
        }
    };
    const reason = {
        parameterPath: [
            "options",
            "reason"
        ],
        mapper: {
            serializedName: "reason",
            type: {
                name: "String"
            }
        }
    };
    const user = {
        parameterPath: "user",
        mapper: {
            required: true,
            serializedName: "user",
            type: {
                name: "String"
            }
        }
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a HealthApi. */
    class HealthApi {
        /**
         * Create a HealthApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        getHealthStatus(options, callback) {
            return this.client.sendOperationRequest({
                options
            }, getHealthStatusOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer = new msRest.Serializer(Mappers);
    const getHealthStatusOperationSpec = {
        httpMethod: "HEAD",
        path: "api/health",
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a WebPubSubApi. */
    class WebPubSubApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, sendToAllOperationSpec, callback);
        }
        checkConnectionExistence(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, checkConnectionExistenceOperationSpec, callback);
        }
        closeClientConnection(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, closeClientConnectionOperationSpec, callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, sendToConnectionOperationSpec, callback);
        }
        checkGroupExistence(hub, group, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                options
            }, checkGroupExistenceOperationSpec, callback);
        }
        sendToGroup(hub, group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                payloadMessage,
                options
            }, sendToGroupOperationSpec, callback);
        }
        addConnectionToGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, addConnectionToGroupOperationSpec, callback);
        }
        removeConnectionFromGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, removeConnectionFromGroupOperationSpec, callback);
        }
        checkUserExistence(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, checkUserExistenceOperationSpec, callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, sendToUserOperationSpec, callback);
        }
        checkUserExistenceInGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, checkUserExistenceInGroupOperationSpec, callback);
        }
        addUserToGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, addUserToGroupOperationSpec, callback);
        }
        removeUserFromGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, removeUserFromGroupOperationSpec, callback);
        }
        removeUserFromAllGroups(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, removeUserFromAllGroupsOperationSpec, callback);
        }
        grantGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, grantGroupPermissionOperationSpec, callback);
        }
        revokeGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, revokeGroupPermissionOperationSpec, callback);
        }
        checkGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, checkGroupPermissionOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer$1 = new msRest.Serializer(Mappers$1);
    const sendToAllOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkConnectionExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const closeClientConnectionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            reason,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToConnectionOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/groups/{group}",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToGroupOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addConnectionToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeConnectionFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToUserOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/users/{id}/:send",
        urlParameters: [
            hub,
            id
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceInGroupOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addUserToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromAllGroupsOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const grantGroupPermissionOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const revokeGroupPermissionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupPermissionOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const packageName = "@azure/webpubsub";
    const packageVersion = "1.0.0";
    class WebPubSubServiceClientContext extends msRestAzure.AzureServiceClient {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            if (credentials == undefined) {
                throw new Error('\'credentials\' cannot be null.');
            }
            if (!options) {
                options = {};
            }
            if (!options.userAgent) {
                const defaultUserAgent = msRestAzure.getDefaultUserAgentValue();
                options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
            }
            super(credentials, options);
            this.acceptLanguage = 'en-US';
            this.longRunningOperationRetryTimeout = 30;
            this.baseUri = options.baseUri || this.baseUri || "http://localhost";
            this.requestContentType = "application/json; charset=utf-8";
            this.credentials = credentials;
            if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
                this.acceptLanguage = options.acceptLanguage;
            }
            if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
                this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
            }
        }
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    class WebPubSubServiceClient extends WebPubSubServiceClientContext {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            super(credentials, options);
            this.healthApi = new HealthApi(this);
            this.webPubSubApi = new WebPubSubApi(this);
        }
    }

    /*
     AutoRest has issue generating code from :
     "consumes": [
              "application/octet-stream",
              "text/plain"
            ],
            "parameters": [
              {
                "in": "body",
                "name": "payloadMessage",
                "required": true,
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }

    */
    /** Class representing a WebPubSubApi. */
    class WebPubSubSendApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, broadcastOperationSpec), callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToUserOperationSpec$1), callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToConnectionOperationSpec$1), callback);
        }
        sendToGroup(group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                group,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, groupBroadcastOperationSpec), callback);
        }
    }
    // Operation Specifications
    const serializer$2 = new msRest.Serializer(Mappers$1);
    const broadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToUserOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/users/{id}/:send",
        urlParameters: [
            hub,
            id
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToConnectionOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const groupBroadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    function fulfillSpec(payloadMessage, baseSepc) {
        if (typeof payloadMessage === "string") {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "String"
                        }
                    }
                }, contentType: "text/plain" });
        }
        else {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "Stream"
                        }
                    }
                }, contentType: "application/octet-stream" });
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubKeyCredentials {
        /**
         * Creates a new TokenCredentials object.
         *
         * @constructor
         * @param {string} key The key.
         */
        constructor(key) {
            if (!key) {
                throw new Error("token cannot be null or undefined.");
            }
            this.key = key;
        }
        /**
         * Signs a request with the Authentication header.
         *
         * @param {WebResourceLike} webResource The WebResourceLike to be signed.
         * @return {Promise<WebResourceLike>} The signed request object.
         */
        signRequest(webResource) {
            var _a;
            if (!webResource.headers)
                webResource.headers = new msRest.HttpHeaders();
            var url = new URL((_a = webResource.url + webResource.query) !== null && _a !== void 0 ? _a : '');
            url.port = '';
            const audience = url.toString();
            webResource.headers.set("Authorization", "Bearer " +
                jwt.sign({}, this.key, {
                    audience: audience,
                    expiresIn: "1h",
                    algorithm: "HS256"
                }));
            return Promise.resolve(webResource);
        }
    }

    // Copyright (c) Microsoft Corporation.
    class ConsoleHttpPipelineLogger {
        /**
         * Create a new ConsoleHttpPipelineLogger.
         * @param minimumLogLevel The log level threshold for what logs will be logged.
         */
        constructor(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
        }
        /**
         * Log the provided message.
         * @param logLevel The HttpLogDetailLevel associated with this message.
         * @param message The message to log.
         */
        log(logLevel, message) {
            const logMessage = `${msRest.HttpPipelineLogLevel[logLevel]}: ${message}`;
            switch (logLevel) {
                case msRest.HttpPipelineLogLevel.ERROR:
                    console.error(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.WARNING:
                    console.warn(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.INFO:
                    console.log(logMessage);
                    break;
            }
        }
    }
    /**
     * Client for connecting to a SignalR hub
     */
    class WebPubSubServiceRestClient {
        constructor(connectionStringOrEndpoint, hub, options) {
            /**
             * The SignalR API version being used by this client
             */
            this.apiVersion = "2020-10-01";
            if (typeof connectionStringOrEndpoint === 'string') {
                this._endpoint = new WebPubSubServiceEndpoint(connectionStringOrEndpoint);
            }
            else {
                this._endpoint = connectionStringOrEndpoint;
            }
            this.hub = hub;
            this.serviceUrl = this._endpoint.endpoint.serviceUrl;
            this.credential = new WebPubSubKeyCredentials(this._endpoint.endpoint.key);
            this.client = new WebPubSubServiceClient(this.credential, {
                //httpPipelineLogger: options?.dumpRequest ? new ConsoleHttpPipelineLogger(HttpPipelineLogLevel.INFO) : undefined,
                baseUri: this._endpoint.endpoint.serviceUrl.href,
                requestPolicyFactories: (options === null || options === void 0 ? void 0 : options.dumpRequest) ? this.getFactoryWithLogPolicy : undefined,
            });
            this.sender = new WebPubSubSendApi(this.client);
        }
        getFactoryWithLogPolicy(defaultRequestPolicyFactories) {
            defaultRequestPolicyFactories.push(msRest.logPolicy());
        }
        /**
         * Check if the service is healthy
         *
         * @param options Additional options
         */
        serviceIsHealthy(options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.client.healthApi.getHealthStatus({
                        apiVersion: options.apiVersion
                    });
                    return true;
                }
                catch (_a) {
                    return false;
                }
                finally {
                }
            });
        }
        sendToAll(message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToAll(this.hub, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToUser(username, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToUser(this.hub, username, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToConnection(connectionId, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToConnection(this.hub, connectionId, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a specific connection is connected to this hub
         *
         * @param connectionId Connection id to check
         * @param options Additional options
         */
        hasConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkConnectionExistence(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Close a specific connection to this hub
         *
         * @param connectionId Connection id to close
         * @param options Additional options
         */
        closeConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.closeClientConnection(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        reason: options.reason
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific user from all groups they are joined to
         * @param userId The user id to remove from all groups
         * @param options Additional options
         */
        removeUserFromAllGroups(userId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromAllGroups(this.hub, userId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular group exists (i.e. has active connections).
         *
         * @param groupName The group name to check for
         * @param options Additional options
         */
        hasGroup(groupName, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkGroupExistence(this.hub, groupName, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular user is connected to this hub.
         *
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUser(username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistence(this.hub, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Add a specific connection to this group
         *
         * @param connectionId The connection id to add to this group
         * @param options Additional options
         */
        addConnectionToGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.addConnectionToGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific connection from this group
         *
         * @param connectionId The connection id to remove from this group
         * @param options Additional options
         */
        removeConnectionFromGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.removeConnectionFromGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Add a user to this group
         *
         * @param username The user name to add
         * @param options Additional options
         */
        addUserToGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.addUserToGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a user is in this group
         *
         * @param groupName The group name to check for
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUserInGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistenceInGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Remove a user from this group
         *
         * @param groupName The group name to check for
         * @param username The user name to remove
         * @param options Additional options
         */
        removeUserFromGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    // FOR now it is still 202, we are changing the service to support 200 soon
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        publish(groupName, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToGroup(groupName, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        verifyResponse(res, successStatus, failureStatus) {
            if (successStatus !== undefined && res._response.status === successStatus) {
                return true;
            }
            if (failureStatus !== undefined && res._response.status === failureStatus) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new msRest.RestError(res._response.bodyAsText, undefined, res._response.status, res._response.request, res._response);
            }
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubServer {
        constructor(conn, hub) {
            this.hub = hub;
            this.endpoint = new WebPubSubServiceEndpoint(conn);
        }
        createCloudEventsHandler(options) {
            return new WebPubSubCloudEventsHandler(this.endpoint, this.hub, options);
        }
        createServiceClient(options) {
            return new WebPubSubServiceRestClient(this.endpoint, this.hub, options);
        }
    }
    class WebPubSubCloudEventsHandler {
        constructor(connectionStringOrEndpoint, hub, options) {
            var _a;
            this.hub = hub;
            if (typeof connectionStringOrEndpoint === 'string') {
                this._endpoint = new WebPubSubServiceEndpoint(connectionStringOrEndpoint);
            }
            else {
                this._endpoint = connectionStringOrEndpoint;
            }
            this.path = ((_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : `/api/webpubsub/hubs/${hub}`).toLowerCase();
            this.hub = hub;
            this._serviceHost = this._endpoint.endpoint.serviceUrl.hostname;
            this._cloudEventsHandler = new ProtocolParser(this.hub, options, options === null || options === void 0 ? void 0 : options.dumpRequest);
        }
        handleRequest(request, response) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                var normalizedUrl = (_a = request.url) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                if (!normalizedUrl) {
                    throw new Error("invalid url");
                }
                if (!(normalizedUrl === this.path || normalizedUrl.startsWith(this.path))) {
                    return false;
                }
                if (this.tryHandleAbuseProtectionRequests(request, response, normalizedUrl)) {
                    return true;
                }
                return yield this.tryHandleCloudEvents(request, response, normalizedUrl);
            });
        }
        getMiddleware() {
            const router = express.Router();
            router.use(this.path, (request, response) => __awaiter(this, void 0, void 0, function* () {
                var normalizedUrl = (this.path + request.url).toLowerCase();
                if (this.tryHandleAbuseProtectionRequests(request, response, normalizedUrl)) {
                    return true;
                }
                yield this.tryHandleCloudEvents(request, response, normalizedUrl);
            }));
            return router;
        }
        tryHandleAbuseProtectionRequests(request, response, url) {
            if (url !== this.path || request.method !== 'OPTIONS') {
                return false;
            }
            if (request.headers['webhook-request-origin'] === this._serviceHost) {
                response.setHeader("WebHook-Allowed-Origin", this._serviceHost);
            }
            else {
                console.log(`Invalid abuse protection request ${request}`);
                response.statusCode = 400;
            }
            response.end();
            return true;
        }
        tryHandleCloudEvents(request, response, url) {
            return __awaiter(this, void 0, void 0, function* () {
                if (url !== this.path) {
                    console.warn(`Url ${url} does not match ${this.path}`);
                    return false;
                }
                if (request.method !== 'POST') {
                    response.statusCode = 400;
                    response.end();
                    return true;
                }
                yield this._cloudEventsHandler.processNodeHttpRequest(request, response);
                return true;
            });
        }
    }

    exports.ConsoleHttpPipelineLogger = ConsoleHttpPipelineLogger;
    exports.WebPubSubCloudEventsHandler = WebPubSubCloudEventsHandler;
    exports.WebPubSubServer = WebPubSubServer;
    exports.WebPubSubServiceEndpoint = WebPubSubServiceEndpoint;
    exports.WebPubSubServiceRestClient = WebPubSubServiceRestClient;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=webpubsub.js.map
