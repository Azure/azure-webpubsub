/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@azure/ms-rest-azure-js'), require('@azure/ms-rest-js'), require('jsonwebtoken'), require('url')) :
    typeof define === 'function' && define.amd ? define(['exports', '@azure/ms-rest-azure-js', '@azure/ms-rest-js', 'jsonwebtoken', 'url'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.WebPubSub = {}), global.msRestAzure, global.msRest, global.jwt, global.URL));
}(this, (function (exports, msRestAzure, msRest, jwt, url) { 'use strict';

    jwt = jwt && Object.prototype.hasOwnProperty.call(jwt, 'default') ? jwt['default'] : jwt;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */
    const CloudError = msRestAzure.CloudErrorMapper;

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const acceptLanguage = {
        parameterPath: "acceptLanguage",
        mapper: {
            serializedName: "accept-language",
            defaultValue: 'en-US',
            type: {
                name: "String"
            }
        }
    };
    const apiVersion = {
        parameterPath: [
            "options",
            "apiVersion"
        ],
        mapper: {
            serializedName: "api-version",
            defaultValue: '2020-10-01',
            type: {
                name: "String"
            }
        }
    };
    const connectionId = {
        parameterPath: "connectionId",
        mapper: {
            required: true,
            serializedName: "connectionId",
            type: {
                name: "String"
            }
        }
    };
    const excluded = {
        parameterPath: [
            "options",
            "excluded"
        ],
        mapper: {
            serializedName: "excluded",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "String"
                    }
                }
            }
        },
        collectionFormat: msRest.QueryCollectionFormat.Multi
    };
    const group0 = {
        parameterPath: "group",
        mapper: {
            required: true,
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const group1 = {
        parameterPath: [
            "options",
            "group"
        ],
        mapper: {
            serializedName: "group",
            type: {
                name: "String"
            }
        }
    };
    const hub = {
        parameterPath: "hub",
        mapper: {
            required: true,
            serializedName: "hub",
            type: {
                name: "String"
            }
        }
    };
    const id = {
        parameterPath: "id",
        mapper: {
            required: true,
            serializedName: "id",
            type: {
                name: "String"
            }
        }
    };
    const permission = {
        parameterPath: "permission",
        mapper: {
            required: true,
            serializedName: "permission",
            type: {
                name: "String"
            }
        }
    };
    const reason = {
        parameterPath: [
            "options",
            "reason"
        ],
        mapper: {
            serializedName: "reason",
            type: {
                name: "String"
            }
        }
    };
    const user = {
        parameterPath: "user",
        mapper: {
            required: true,
            serializedName: "user",
            type: {
                name: "String"
            }
        }
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a HealthApi. */
    class HealthApi {
        /**
         * Create a HealthApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        getHealthStatus(options, callback) {
            return this.client.sendOperationRequest({
                options
            }, getHealthStatusOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer = new msRest.Serializer(Mappers);
    const getHealthStatusOperationSpec = {
        httpMethod: "HEAD",
        path: "api/health",
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */

    var Mappers$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CloudError: CloudError
    });

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    /** Class representing a WebPubSubApi. */
    class WebPubSubApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, sendToAllOperationSpec, callback);
        }
        checkConnectionExistence(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, checkConnectionExistenceOperationSpec, callback);
        }
        closeClientConnection(hub, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                options
            }, closeClientConnectionOperationSpec, callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, sendToConnectionOperationSpec, callback);
        }
        checkGroupExistence(hub, group, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                options
            }, checkGroupExistenceOperationSpec, callback);
        }
        sendToGroup(hub, group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                payloadMessage,
                options
            }, sendToGroupOperationSpec, callback);
        }
        addConnectionToGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, addConnectionToGroupOperationSpec, callback);
        }
        removeConnectionFromGroup(hub, group, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                connectionId,
                options
            }, removeConnectionFromGroupOperationSpec, callback);
        }
        checkUserExistence(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, checkUserExistenceOperationSpec, callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, sendToUserOperationSpec, callback);
        }
        checkUserExistenceInGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, checkUserExistenceInGroupOperationSpec, callback);
        }
        addUserToGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, addUserToGroupOperationSpec, callback);
        }
        removeUserFromGroup(hub, group, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                group,
                user,
                options
            }, removeUserFromGroupOperationSpec, callback);
        }
        removeUserFromAllGroups(hub, user, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                user,
                options
            }, removeUserFromAllGroupsOperationSpec, callback);
        }
        grantGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, grantGroupPermissionOperationSpec, callback);
        }
        revokeGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, revokeGroupPermissionOperationSpec, callback);
        }
        checkGroupPermission(hub, permission, connectionId, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                permission,
                connectionId,
                options
            }, checkGroupPermissionOperationSpec, callback);
        }
    }
    // Operation Specifications
    const serializer$1 = new msRest.Serializer(Mappers$1);
    const sendToAllOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkConnectionExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const closeClientConnectionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/connections/{connectionId}",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            reason,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToConnectionOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/groups/{group}",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToGroupOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addConnectionToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeConnectionFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/groups/{group}/connections/{connectionId}",
        urlParameters: [
            hub,
            group0,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const sendToUserOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/users/{id}/:send",
        urlParameters: [
            hub,
            id
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        requestBody: {
            parameterPath: "payloadMessage",
            mapper: {
                required: true,
                serializedName: "payloadMessage",
                type: {
                    name: "String"
                }
            }
        },
        contentType: "application/octet-stream",
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkUserExistenceInGroupOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const addUserToGroupOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromGroupOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups/{group}",
        urlParameters: [
            hub,
            group0,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const removeUserFromAllGroupsOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/users/{user}/groups",
        urlParameters: [
            hub,
            user
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const grantGroupPermissionOperationSpec = {
        httpMethod: "PUT",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const revokeGroupPermissionOperationSpec = {
        httpMethod: "DELETE",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };
    const checkGroupPermissionOperationSpec = {
        httpMethod: "HEAD",
        path: "api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
        urlParameters: [
            hub,
            permission,
            connectionId
        ],
        queryParameters: [
            group1,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            200: {},
            404: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$1
    };

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    const packageName = "@azure/webpubsub";
    const packageVersion = "1.0.0";
    class WebPubSubServiceClientContext extends msRestAzure.AzureServiceClient {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            if (credentials == undefined) {
                throw new Error('\'credentials\' cannot be null.');
            }
            if (!options) {
                options = {};
            }
            if (!options.userAgent) {
                const defaultUserAgent = msRestAzure.getDefaultUserAgentValue();
                options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
            }
            super(credentials, options);
            this.acceptLanguage = 'en-US';
            this.longRunningOperationRetryTimeout = 30;
            this.baseUri = options.baseUri || this.baseUri || "http://localhost";
            this.requestContentType = "application/json; charset=utf-8";
            this.credentials = credentials;
            if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
                this.acceptLanguage = options.acceptLanguage;
            }
            if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
                this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
            }
        }
    }

    /*
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    class WebPubSubServiceClient extends WebPubSubServiceClientContext {
        /**
         * Initializes a new instance of the WebPubSubServiceClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        constructor(credentials, options) {
            super(credentials, options);
            this.healthApi = new HealthApi(this);
            this.webPubSubApi = new WebPubSubApi(this);
        }
    }

    /*
     AutoRest has issue generating code from :
     "consumes": [
              "application/octet-stream",
              "text/plain"
            ],
            "parameters": [
              {
                "in": "body",
                "name": "payloadMessage",
                "required": true,
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }

    */
    /** Class representing a WebPubSubApi. */
    class WebPubSubSendApi {
        /**
         * Create a WebPubSubApi.
         * @param {WebPubSubServiceClientContext} client Reference to the service client.
         */
        constructor(client) {
            this.client = client;
        }
        sendToAll(hub, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, broadcastOperationSpec), callback);
        }
        sendToUser(hub, id, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                id,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToUserOperationSpec$1), callback);
        }
        sendToConnection(hub, connectionId, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                hub,
                connectionId,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, sendToConnectionOperationSpec$1), callback);
        }
        sendToGroup(group, payloadMessage, options, callback) {
            return this.client.sendOperationRequest({
                group,
                payloadMessage,
                options
            }, fulfillSpec(payloadMessage, groupBroadcastOperationSpec), callback);
        }
    }
    // Operation Specifications
    const serializer$2 = new msRest.Serializer(Mappers$1);
    const broadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/:send",
        urlParameters: [
            hub
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToUserOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/users/{id}/:send",
        urlParameters: [
            id
        ],
        queryParameters: [
            hub,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const sendToConnectionOperationSpec$1 = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/connections/{connectionId}/:send",
        urlParameters: [
            hub,
            connectionId
        ],
        queryParameters: [
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    const groupBroadcastOperationSpec = {
        httpMethod: "POST",
        path: "api/hubs/{hub}/groups/{group}/:send",
        urlParameters: [
            hub,
            group0
        ],
        queryParameters: [
            excluded,
            apiVersion
        ],
        headerParameters: [
            acceptLanguage
        ],
        responses: {
            202: {},
            default: {
                bodyMapper: CloudError
            }
        },
        serializer: serializer$2
    };
    function fulfillSpec(payloadMessage, baseSepc) {
        console.log("fulfill");
        if (typeof payloadMessage === "string") {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "String"
                        }
                    }
                }, contentType: "text/plain" });
        }
        else {
            return Object.assign(Object.assign({}, baseSepc), { requestBody: {
                    parameterPath: "payloadMessage",
                    mapper: {
                        required: true,
                        serializedName: "payloadMessage",
                        type: {
                            name: "Stream"
                        }
                    }
                }, contentType: "application/octet-stream" });
        }
    }

    // Copyright (c) Microsoft Corporation.
    class WebPubSubKeyCredentials {
        /**
         * Creates a new TokenCredentials object.
         *
         * @constructor
         * @param {string} key The key.
         */
        constructor(key) {
            if (!key) {
                throw new Error("token cannot be null or undefined.");
            }
            this.key = key;
        }
        /**
         * Signs a request with the Authentication header.
         *
         * @param {WebResourceLike} webResource The WebResourceLike to be signed.
         * @return {Promise<WebResourceLike>} The signed request object.
         */
        signRequest(webResource) {
            var _a;
            if (!webResource.headers)
                webResource.headers = new msRest.HttpHeaders();
            var url = new URL((_a = webResource.url + webResource.query) !== null && _a !== void 0 ? _a : '');
            url.port = '';
            const audience = url.toString();
            webResource.headers.set("Authorization", "Bearer " +
                jwt.sign({}, this.key, {
                    audience: audience,
                    expiresIn: "1h",
                    algorithm: "HS256"
                }));
            return Promise.resolve(webResource);
        }
    }

    // Copyright (c) Microsoft Corporation.
    class ConsoleHttpPipelineLogger {
        /**
         * Create a new ConsoleHttpPipelineLogger.
         * @param minimumLogLevel The log level threshold for what logs will be logged.
         */
        constructor(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
        }
        /**
         * Log the provided message.
         * @param logLevel The HttpLogDetailLevel associated with this message.
         * @param message The message to log.
         */
        log(logLevel, message) {
            const logMessage = `${msRest.HttpPipelineLogLevel[logLevel]}: ${message}`;
            switch (logLevel) {
                case msRest.HttpPipelineLogLevel.ERROR:
                    console.error(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.WARNING:
                    console.warn(logMessage);
                    break;
                case msRest.HttpPipelineLogLevel.INFO:
                    console.log(logMessage);
                    break;
            }
        }
    }
    /**
     * Client for connecting to a SignalR hub
     */
    class WebPubSubServiceRestClient {
        constructor(connectionString, hub, options) {
            /**
             * The SignalR API version being used by this client
             */
            this.apiVersion = "2020-10-01";
            this.hub = hub;
            var endpoint = this.parseConnectionString(connectionString);
            if (endpoint === null) {
                throw new msRest.RestError("Invalid connection string: " + connectionString);
            }
            this.credential = new WebPubSubKeyCredentials(endpoint.key);
            this.client = new WebPubSubServiceClient(this.credential, {
                //httpPipelineLogger: options?.dumpRequest ? new ConsoleHttpPipelineLogger(HttpPipelineLogLevel.INFO) : undefined,
                baseUri: endpoint.host,
                requestPolicyFactories: (options === null || options === void 0 ? void 0 : options.dumpRequest) ? this.getFactoryWithLogPolicy : undefined,
            });
            this.sender = new WebPubSubSendApi(this.client);
        }
        getFactoryWithLogPolicy(defaultRequestPolicyFactories) {
            defaultRequestPolicyFactories.push(msRest.logPolicy());
        }
        parseConnectionString(conn) {
            const em = /Endpoint=(.*?)(;|$)/g.exec(conn);
            if (!em)
                return null;
            const endpoint = em[1];
            const km = /AccessKey=(.*?)(;|$)/g.exec(conn);
            if (!km)
                return null;
            const key = km[1];
            if (!endpoint || !key)
                return null;
            const pm = /Port=(.*?)(;|$)/g.exec(conn);
            const port = pm == null ? '' : pm[1];
            var url$1 = new url.URL(endpoint);
            url$1.port = port;
            const host = url$1.toString();
            url$1.port = '';
            const audience = url$1.toString();
            return {
                host: host,
                audience: audience,
                key: key,
                wshost: host.replace('https://', 'wss://').replace('http://', 'ws://')
            };
        }
        /**
         * Check if the service is healthy
         *
         * @param options Additional options
         */
        serviceIsHealthy(options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.client.healthApi.getHealthStatus({
                        apiVersion: options.apiVersion
                    });
                    return true;
                }
                catch (_a) {
                    return false;
                }
                finally {
                }
            });
        }
        sendToAll(message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToAll(this.hub, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToUser(username, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToUser(this.hub, username, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        sendToConnection(connectionId, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToConnection(this.hub, connectionId, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a specific connection is connected to this hub
         *
         * @param connectionId Connection id to check
         * @param options Additional options
         */
        hasConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkConnectionExistence(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Close a specific connection to this hub
         *
         * @param connectionId Connection id to close
         * @param options Additional options
         */
        closeConnection(connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.closeClientConnection(this.hub, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        reason: options.reason
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific user from all groups they are joined to
         * @param userId The user id to remove from all groups
         * @param options Additional options
         */
        removeUserFromAllGroups(userId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromAllGroups(this.hub, userId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular group exists (i.e. has active connections).
         *
         * @param groupName The group name to check for
         * @param options Additional options
         */
        hasGroup(groupName, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkGroupExistence(this.hub, groupName, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Check if a particular user is connected to this hub.
         *
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUser(username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistence(this.hub, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Add a specific connection to this group
         *
         * @param connectionId The connection id to add to this group
         * @param options Additional options
         */
        addConnectionToGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.addConnectionToGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Remove a specific connection from this group
         *
         * @param connectionId The connection id to remove from this group
         * @param options Additional options
         */
        removeConnectionFromGroup(groupName, connectionId, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.removeConnectionFromGroup(this.hub, groupName, connectionId, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Add a user to this group
         *
         * @param username The user name to add
         * @param options Additional options
         */
        addUserToGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.addUserToGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 202);
                }
                finally {
                }
            });
        }
        /**
         * Check if a user is in this group
         *
         * @param groupName The group name to check for
         * @param username The user name to check for
         * @param options Additional options
         */
        hasUserInGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield this.client.webPubSubApi.checkUserExistenceInGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        /**
         * Remove a user from this group
         *
         * @param groupName The group name to check for
         * @param username The user name to remove
         * @param options Additional options
         */
        removeUserFromGroup(groupName, username, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.client.webPubSubApi.removeUserFromGroup(this.hub, groupName, username, {
                        apiVersion: options.apiVersion,
                        hub: this.hub
                    });
                    // FOR now it is still 202, we are changing the service to support 200 soon
                    return this.verifyResponse(res, 200, 404);
                }
                finally {
                }
            });
        }
        publish(groupName, message, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    var res = yield this.sender.sendToGroup(groupName, message, {
                        apiVersion: options.apiVersion,
                        hub: this.hub,
                        excluded: options.excludedConnections
                    });
                    return this.verifyResponse(res, 200);
                }
                finally {
                }
            });
        }
        verifyResponse(res, successStatus, failureStatus) {
            if (successStatus !== undefined && res._response.status === successStatus) {
                return true;
            }
            if (failureStatus !== undefined && res._response.status === failureStatus) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new msRest.RestError(res._response.bodyAsText, undefined, res._response.status, res._response.request, res._response);
            }
        }
    }

    exports.ConsoleHttpPipelineLogger = ConsoleHttpPipelineLogger;
    exports.WebPubSubServiceRestClient = WebPubSubServiceRestClient;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=webpubsub.js.map
