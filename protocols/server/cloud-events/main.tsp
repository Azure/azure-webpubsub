import "@typespec/http";
import "@typespec/openapi3";
using TypeSpec.Http;

/**
 * This event is triggered when the service receive an MQTT CONNECT packet.
 */
@route("OnMqttClientConnect/DoesNotMatter/DependOnYourEventHandlerSettings")
op OnMqttConnect(
    @header contentType: "application/json",

    /**
     * A unique ID generated by the service for each physical connection. Its format may change, and you shouldn't try to parse it.
     */
    @header("ce-physicalConnectionId") _: string,

    @bodyRoot
    req: MqttConnectEventRequest & CommonRequestHeaders,
): {
    @statusCode _: 202;
} | {
    @statusCode _: 200;
    @header contentType: "application/json";
    @body res: MqttConnectEventSuccessResponse;
} | {
    /**
     * All the status codes not in range 200-299 are considered as a failure response.
     */
    @statusCode _: 401 | 403 | 500;

    @header contentType: "application/json";
    @body res: MqttConnectEventFailureResponse;
};

/**
 * This event is triggered when the service establishes a Web PubSub CONNECTION(aka. session, not a network connection) with a client.
 */
@route("OnMqttClientConnected/DoesNotMatter/DependOnYourEventHandlerSettings")
op OnMqttClientConnected(
    /**
     * A unique ID generated by the service for each physical connection. Its format may change, and you shouldn't try to parse it.
     */
    @header("ce-physicalConnectionId") _: string,

    @bodyRoot
    req: EmptyConnectedEventRequest & CommonRequestHeaders,
): {};

/**
 * This event is triggered when a Web PubSub CONNECTION(aka. session, not a network connection) is ended.
 */
@route("OnMqttClientDisconnected/DoesNotMatter/DependOnYourEventHandlerSettings")
op OnMqttClientDisconnected(
    @header contentType: "application/json",

    /**
     * A unique ID generated by the service for each physical connection. Its format may change, and you shouldn't try to parse it.
     */
    @header("ce-physicalConnectionId") _: string,

    @bodyRoot
    req: MqttDisconnectedEventRequest & CommonRequestHeaders,
): {};

model EmptyConnectedEventRequest {}

/**
 * Represents a request for a connection event.
 */
model ConnectEventRequest {
    claims: Record<string[]>;
    query: Record<string[]>;
    headers: Record<string[]>;
    subprotocols: string[];
    clientCertificates: ClientCertificateInfo[];
}

model ClientCertificateInfo {
    thumbprint: string;
    content: string;
}

/**
 * Represents a request for an MQTT connection event.
 */
model MqttConnectEventRequest extends ConnectEventRequest {
    mqtt: MqttConnectEventProperties;
}

/**
 * Represents the properties of an MQTT connection.
 */
model MqttConnectEventProperties {
    /**
     * MQTT protocol version. The same as the CONNECT packet's ProtocolVersion.
     * MQTT 3.1.1 is 4, MQTT 5.0 is 5.
     */
    protocolVersion: integer;

    /**
     * The username field in the MQTT CONNECT packet.
     */
    username?: string;

    /**
     * The base64 encoded password field in the MQTT CONNECT packet.
     */
    password?: string;

    /**
     * The user properties in the MQTT CONNECT packet.
     */
    userProperties?: MqttUserProperty[];
}

/**
 * Represents a user property in an MQTT connection.
 */
model MqttUserProperty {
    name: string;
    value: string;
}

/**
 * Represents a successful response to an MQTT connection event.
 */
model MqttConnectEventSuccessResponse {
    /**
     * The property provides a way for the upstream Webhook to authorize the client. There are different roles to grant initial permissions for PubSub WebSocket clients. See details in https://learn.microsoft.com/azure/azure-web-pubsub/concept-client-protocols#permissions
     */
    roles?: string[];

    /**
     * It should be "mqtt" or omitted.
     */
    subprotocol?: string;

    /**
     * As the service allows anonymous connections, it's the connect event's responsibility to tell the service the user ID of the client connection. The service reads the user ID from the response payload userId if it exists.
     */
    userId?: string;

    /**
     * Initial groups the client joins. The property provides a convenient way for user to add the client to one or multiple groups. In this way, there's no need to have another call to add this connection to some groups.
     */
    groups?: string[];

    mqtt?: MqttConnectEventSuccessResponseProperties;
}

/**
 * Represents the MQTT specific properties in a successful MQTT connection event response.
 */
model MqttConnectEventSuccessResponseProperties {
    /**
     *It's additional diagnostic or other information provided by upstream server. They'll be converted to the user properties field in the CONNACK packet, and sent to clients whose protocols support user properties. Now only MQTT 5.0 supports user properties. Upstream webhook can use the property to communicate additional diagnostic or other information with clients.
     */
    userProperties?: MqttUserProperty[];
}

/**
 * Represents the response properties of an MQTT connection failure.
 */
model MqttConnectEventFailureResponse {
    mqtt: MqttConnectEventFailureResponseProperties;
}

/**
 * Represents the properties of an MQTT connection failure response.
 */
model MqttConnectEventFailureResponseProperties {
    /**
     * The failure code. It will be sent to the clients in the CONNACK packet as a return code (MQTT 3.1.1) or reason code (MQTT 5.0). Upstream webhook should select a valid integer value defined the MQTT protocols according to the protocol versions of the clients. If Upstream webhook sets an invalid value, clients will receive "unspecified error" in the CONNACK packet.
     */
    code: integer;

    /**
     * The reason for the failure. It's a human readable failure reason string designed for diagnostics. It will be sent to those clients whose protocols support reason string in the CONNACK packet. Now only MQTT 5.0 supports it.
     */
    reason?: string;

    /**
     * The user properties associated with the failure. They'll be converted to user properties in the CONNACK packet, and sent to clients whose protocols support user properties. Now only MQTT 5.0 supports user properties. Upstream webhook can use the property for additional diagnostic or other information.
     */
    userProperties?: MqttUserProperty[];
}

model CommonRequestHeaders {
    /**
     * The user the connection authed.
     */
    @header("ce-userId") userId?: string;

    /**
     * The hub the connection belongs to.
     */
    @header("ce-hub") hub: string;

    /**
     * The connectionId is unique for the client connection.
     */
    @header("ce-connectionId") connectionId: string;

    /**
     * The name of the event without prefix.
     */
    @header("ce-eventName") eventName: string;

    /**
     * The subprotocol the client is using if any.
     */
    @header("ce-subprotocol") subprotocol?: string;

    /**
     * Defines the state for the connection. You can use the same response header to reset the value of the state. Multiple `connectionState` headers aren't allowed. Do base64 encode the string value if it contains complex characters inside, for example, `base64(jsonString)` to pass complex object using this attribute.
     */
    @header("ce-connectionState") connectionState?: string;

    /**
     * The signature for the upstream webhook to validate if the incoming request is from the expected origin. The service calculates the value using both primary access key and secondary access key as the `HMAC` key: `Hex_encoded(HMAC_SHA256(accessKey, connectionId))`. The upstream should check if the request is valid before processing it.
     */
    @header("ce-signature") signature?: string;
}

/**
 * Represents a request for a disconnection event.
 */
model DisconnectEventRequest {
    reason: string;
}

/**
 * Represents a request for an MQTT disconnection event.
 */
model MqttDisconnectedEventRequest extends DisconnectEventRequest {
    mqtt: MqttDisconnectedEventProperties;
}

/**
 * Represents the properties of an MQTT disconnection event.
 */
model MqttDisconnectedEventProperties {
    /**
     * Indicates whether the disconnection is initiated by the client.
     */
    initiatedByClient: boolean;

    /**
     * The DISCONNECT packet properties to end the last physical connection.
     * It may be sent by the client or server.
     */
    disconnectPacket?: MqttDisconnectPacketProperties;
}

/**
 * Represents the properties of an MQTT DISCONNECT packet.
 */
model MqttDisconnectPacketProperties {
    /**
     * The DISCONNECT reason code defined in MQTT 5.0 spec.
     * For MQTT 3.1.1 clients, it's always the default value 0.
     */
    code: integer;

    /**
     * The user properties in the DISCONNECT packet sent by the client.
     * The value is not null only if the client sent a DISCONNECT packet with user properties.
     */
    userProperties?: MqttUserProperty[];
}
